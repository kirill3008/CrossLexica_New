     { WARNINGS about OPFUNCxx.TXT files content: 
  1. One-word noun vocables should include all homonymous options
     occurring elsewhere, as well as all coordinate noun pairs 
     occurring in SUPNOM files (except pairs of personal names).
  2. Managing verbs should include all homonymous verbs occurring 
     elsewhere.
  3. The widest possible use of prepositions registered in PREPOS 
     array is our goal. Some of already registered prepositions 
     are absent in verb-to-noun collocatios so far, whie SUPNOM 
     files with noun-to-noun collocations deliver additional ones. }

PROGRAM ENCODEOB2;

USES DOS, CLASTABL, INITVER4;

  TYPE
    STR115 = STRING [115];
    STR35 = STRING [39];
    SCALE = (NOTNUM, UNUS, SMALL, BIG1, BIG2);

  CONST
    MAXPART = 900;
    MAXSHORT = 360;
    MINEXAMPL = 20;
    MAXEXAMPL = 50;

    GAP = 24;

    SUFS : ARRAY [1..53] OF STRING [4] =
     ('', '', '', '', '', '', '', '', '',
      '', '', '', '', '', '', '', '', '',
      '', '', '', '', '', '', '', '',
      '', '', '', '', '', '', '', '',
      '', '', '', '', '', '', '', '', '', 
      '', '', '', '', '', '', '', '', '', '');
    TAB = #009;
    VERBTAILMAX = 26;
    VERBTAIL : ARRAY [1..VERBTAILMAX] OF STRING [14] = 
      (' ','','','',
       '','','',
       '','','',' ','',
       '','',' ','',
       '',' ','',
       '','','','',
       '','','');
    CASNO : ARRAY [NOM..LOC] OF STR3 =
       ('NOM','GEN','DAT','ACC','INS','PRE','PAR','LOC');

   VAR
CLASS, SUBCL, ANIMSUBCL, DEANCL, ANCL, ANSUBCL,
  P, PI, PILI, PH, PK, IDIOM, STYL, ERC, ALLSOB, 
  INISOB, L1, QV, QP, QS, CLSI, D, PU, PB : INTEGER;
INP, OUT, OUT1, OUT2, OUT3, OUT4, OUT5, OUT6, OUTF, OUTG : TEXT;
LINENUM, J, AMT0, AMT11, AMT12, AMT13, AMT14, AMT15,
  AMT2, TOTAL, AMT, I, PARTAMT, GRNUM, CURSHORT : LONGINT;
FIRST, USACH : CHAR;
USECOUNT: ARRAY [1..5] OF LONGINT;
FNAME, FNAMEOUT{, FNAMEOUT1} : STRING [12];
LINE, HEADLINE, HEADER, SUBHEAD, VERB, TOK1, TOK2, PART2,
  PREVHEAD, CURHEAD, TRUNKV, TRUNKP, TRUNKS, PREPI : STR115;
VALID, SUBVAL, NG_CHANGE, DOUBLE_FL, FL_REVERS,
  THERE_IS_I, THERE_IS_H, THERE_IS_VLN, VALI : BOOLEAN;
NUMB, NUMB0, SUBNUMB, NMBI : NUMBER;
GEND, { gender implied by the verb }
GEND0, { gender of the noun } 
SUBGEND, ADJ_GEND, GNDI : GENDER;
ANIM, ANIM0, SUBANIM, ANMI : ANIMA;
CAS_WO_PREP : ARRAY [0..7] OF LONGINT;
SOB_COUNT : ARRAY [0..48] OF LONGINT;
PREPO : ARRAY [8..MAXPREP29] OF LONGINT;
PREPOTOTAL, WOPREPTOTAL : LONGINT;
VLNPAR : ARRAY [1..MAXSHORT, 1..2] OF INTEGER;{ vlong noun numbs & gends }
VLNSTR : ARRAY [1..MAXSHORT] OF STR115;        { vlong noun strings }

CASESETS : ARRAY [8..MAXPREP29] OF
  RECORD
    PREPCODE : LONGINT;
    EXAMQUAN : INTEGER;
    CASNAME : CASUS;
    CASTRING : STR35;
    EXAMPLES : ARRAY [0..MAXEXAMPL] OF ARRAY [1..2] OF STR35;
    EXAMPLES2 : ARRAY [0..MAXEXAMPL] OF STR115;
  END;

PARTARR : ARRAY [1..MAXPART] OF
  RECORD
    WHOLINE : STR115;     { Whole line from 3rd position } 
    NEG   : BOOLEAN;     { Sign of leading NE }
    TOKN  : STR115;       { Verb }
    VCLAS : INTEGER;     { Verb class}
    SOBN  : INTEGER;     { Identifier of reflexive with "/" }
    ONLYDOT : INTEGER;   { Sign of internal/trailing dots }
    PREPSTR : STR115;     { Preposition }
    GCAS  : INTEGER;     { Number of generalized case }
    FLEX  : STR11;       { Flection }
    FLX1  : STR11;       { Additional flection }
    IDI   : INTEGER;     { Sign of figurativity }
    STY   : INTEGER;     { Sign of style }
  END;

CONST NOGCAS = 255; { This GCAS not to be assigned }


{ Is preposition TOKEN among 32 top frequent in XL DB? }
FUNCTION IN_TOP_32 (TOKEN : STR115) : BOOLEAN;
        {=========}
  CONST
    TOKMAX0 = 32;
    TOP_32 : ARRAY [1..TOKMAX0] OF STRING [12] =
      ('2','1','1','','2','2','',
       '1','','1','2',' ','1',
       '','2','','','','',
       '-','',' ',' ',
       '1','2','','','','5',
       ' ','','' );
  VAR
    I : INTEGER;
    FOUND : BOOLEAN;
BEGIN
  FOUND := FALSE;
  I := 0;
  REPEAT
    INC (I);
    FOUND := (TOP_32 [I] = TOKEN);
  UNTIL FOUND OR (I = TOKMAX0);
  IN_TOP_32 := FOUND;
END;

{ Initialization of very long nouns short list }
PROCEDURE VLN_ARRAY_SHORT;
         {===============}
VAR
  I : INTEGER;
  LINE : STR115;
  XL_DAS : STRING [255];
  INP : TEXT;
BEGIN
 { For reference file name }
  XL_DAS := GetEnv ('XL_DAS_PATH');
  IF XL_DAS = '' 
    THEN XL_DAS := '../DAS/';

 { Initiate array }
  ASSIGN (INP, XL_DAS+'FORBASE.DAS');
  RESET (INP);
  I := 0;
  REPEAT
    INC (I);
    READLN (INP, LINE);
    VLNPAR [I, 1] := ORD(LINE [1]) - ORD('0');
    VLNPAR [I, 2] := ORD(LINE [3]) - ORD('0');
    VLNSTR [I] := COPY (LINE, 5, LENGTH(LINE)-4);
  UNTIL EOF (INP) OR (I = MAXSHORT);
  CURSHORT := I;
  CLOSE (INP);
  writeln ('VLN_SHORTS are ', CURSHORT);
END;

{ TOKEN is among very long nouns short list }
FUNCTION AMONG_VLN_SHORTS (TOKEN : STR115;
        {================} VAR NUMR : NUMBER;
                           VAR GNDR : GENDER) : BOOLEAN;
VAR
  I : INTEGER;
  FOUND : BOOLEAN;
{  RES : RESTYPE; }          
BEGIN
  NUMR := UNKN;
  GNDR := NONE;

  FOUND := FALSE;
  I := 0;
  REPEAT
    INC (I);
    FOUND := (TOKEN = VLNSTR[I]);
  UNTIL FOUND OR (I = CURSHORT);

  IF FOUND
    THEN 
      BEGIN
        NUMR := NUMBER (VLNPAR [I,1]);
        GNDR := GENDER (VLNPAR [I,2]);
      END;
  AMONG_VLN_SHORTS := FOUND;
END;


{ PART1 may be numeral of any SCALE }
FUNCTION AMONG_NUMERALS (PART : STR115;
        {==============} VAR ERC : INTEGER) : SCALE;
CONST
  MAXUNUS = 3;
  UNUSW : ARRAY [1..MAXUNUS] OF STR7 = 
('','','');
  MAXSMALL = 8;
  SMALLW : ARRAY [1..MAXSMALL] OF STR7 =
('','','','',
'','','','');
  MAXBIG1 = 9;
  BIGW1 : ARRAY [1..MAXBIG1] OF STRING [13] =
('','','','','',
'','','','');
  MAXBIG2 = 39;
  BIGW2 : ARRAY [1..MAXBIG2] OF STRING [13] =
('','','','','',
'','','',
'','','',
'','','',
'','','','',
'','','',
'','','',
'','','','',
'','','','',
'','','',
'','','','');
VAR
  I, NUM : INTEGER;
  SCL : SCALE;
  FOUND : BOOLEAN;
BEGIN
  VAL (PART, NUM, ERC);
  IF ERC = 0
    THEN
      BEGIN
        IF ((NUM MOD 100) DIV 10 = 1)
          THEN SCL := BIG2
          ELSE
            CASE (NUM MOD 10) OF
              1 : SCL := UNUS;
              2, 3, 4 : SCL := SMALL;
              0, 5, 6, 7, 8, 9 : SCL := BIG2;
            END;
      END
  ELSE 
    BEGIN
      I := 0;
      REPEAT
        INC(I);
        FOUND := (PART = UNUSW[I]);
      UNTIL FOUND OR (I = MAXUNUS);
      IF FOUND 
        THEN SCL := UNUS
        ELSE
          BEGIN
            I := 0;
            REPEAT
              INC(I);
              FOUND := (PART = SMALLW[I]);
            UNTIL FOUND OR (I = MAXSMALL);
            IF FOUND 
              THEN SCL := SMALL
                ELSE
                  BEGIN
                    I := 0;
                    REPEAT
                      INC(I);
                      FOUND := (PART = BIGW1[I]);
                    UNTIL FOUND OR (I = MAXBIG1);
                    IF FOUND 
                      THEN SCL := BIG1
                      ELSE
                        BEGIN
                          I := 0;
                          REPEAT
                            INC(I);
                            FOUND := (PART = BIGW2[I]);
                          UNTIL FOUND OR (I = MAXBIG2);
                          IF FOUND 
                            THEN SCL := BIG2
                            ELSE SCL := NOTNUM;
                        END;
                  END;
          END;
    END;
  AMONG_NUMERALS := SCL;
END;

{ Initiate ARRAY content }
PROCEDURE INIT_ARRAY;
         {==========}
  VAR I : INTEGER;
BEGIN
  FOR I := 1 TO MAXPART DO
    WITH PARTARR [I] DO
      BEGIN
        WHOLINE := DUMMY;
        NEG  := FALSE;
        TOKN := DUMMY;
        VCLAS := 0;
        SOBN := 0;
        ONLYDOT := 0;
        PREPSTR := DUMMY;
        GCAS := 3;           {!!!}
        FLEX := DUMMY;
        FLX1 := DUMMY;
        IDI := 0;
        STY := 0;
      END;
 END;

FUNCTION HASFIN (TOKEN : STR115;
        {======} FINAL : STR5) : BOOLEAN;
  VAR L : INTEGER;
BEGIN
  L := LENGTH (FINAL);
  HASFIN := COPY (TOKEN, LENGTH(TOKEN)-L+1, L) = FINAL;
END;

{ 'Feminine' noun CLASS with the same endings 
   N = 1: in GEN and DAT ases 
   N = 2: in GEN, DAT, and INS ases }
FUNCTION FEMIN (CLASS : INTEGER; N : INTEGER) : BOOLEAN;
        {=====}
CONST
  FEMCL1 : ARRAY [1..7] OF INTEGER =
(64, 65, 66, 67, 70, 75, 76);
  FEMCL2 : ARRAY [1..9] OF INTEGER =
(82, 83, 141, 179, 185, 200, 213, 220, 224);
VAR 
  I, L : INTEGER; 
  FOUND : BOOLEAN;
BEGIN
  FOUND:=FALSE;
  CASE N OF
    1:L:=7; 2:L:=9
  END;
  I:=0;
  REPEAT 
    INC(I); 
    FOUND := (N=1) AND (FEMCL1[I] = CLASS)
      OR (N=2) AND (FEMCL2[I] = CLASS);
  UNTIL FOUND OR (I = L);
  FEMIN := FOUND;
END;

{ Simple subject NUMB and GEND determining  
  based on its predicate VERB form }
PROCEDURE TEST_VERB_FIN (VERB : STR115;
         {=============} VAR NUMB : NUMBER;
                         VAR GEND : GENDER);
  VAR 
    L : INTEGER;
BEGIN
  L := LENGTH (VERB);
  NUMB := UNKN;
  GEND := NONE;
  IF HASFIN (VERB, '') OR HASFIN (VERB, '')
    THEN
      BEGIN
        NUMB := SING;
        GEND := FEM;
      END
  ELSE IF HASFIN (VERB, '') OR HASFIN (VERB, '')
    THEN
      BEGIN
        NUMB := SING;
        GEND := NEUT;
      END
  ELSE IF HASFIN (VERB, '') OR HASFIN (VERB, '') OR HASFIN (VERB, '')
    THEN
      BEGIN
        NUMB := PLUR;
        GEND := COMN;
      END
  ELSE IF (POS (VERB [L], '') > 0) OR HASFIN (VERB, '')
    OR HASFIN (VERB, '') OR (VERB = '') OR (VERB = '')
    THEN
      BEGIN
        NUMB := SING;
        GEND := MASC;
      END
  ELSE IF HASFIN (VERB, '') OR HASFIN (VERB, '')
    OR HASFIN (VERB, '') OR HASFIN (VERB, '')
    OR HASFIN (VERB, '')
    THEN
      BEGIN
        NUMB := PLUR;
        GEND := COMN;
      END
  ELSE IF HASFIN (VERB, '') OR HASFIN (VERB, '')
    THEN NUMB := SING;
END;

  { Classify verb to VERBCL }
PROCEDURE CLASSIFY_VERB (VTOK : STR115;
         {=============} VAR VERBCL : INTEGER);
  VAR
    L : INTEGER;
    TMP : STR115;
    VALID : BOOLEAN;
BEGIN
  L := LENGTH (VTOK);
  IF (POS (VTOK [L], '123456') > 0)
    THEN TMP := COPY (VTOK, 1, L-1)
    ELSE TMP := VTOK;
  VALID := TRUE;

  IF ((TMP = '') AND (VTOK [L] = '2'))
    OR ((TMP='') AND (VTOK [L] = '1'))
    OR ((TMP='') AND (VTOK [L] = '2'))
    OR (TMP='') OR (TMP='')
    THEN VERBCL := 10
  ELSE IF ((TMP = '') AND (VTOK [L] = '1'))
    OR ((TMP='') AND (VTOK [L] = '2'))
    OR ((TMP='') AND (VTOK [L] = '1'))
    OR (TMP='') OR (TMP='')
    THEN VERBCL := 16
  ELSE IF (TMP='') AND (VTOK [L] = '3')
      OR (TMP='') AND (VTOK [L] = '2')
    THEN VERBCL := 41
  ELSE IF ((TMP='') OR (TMP='')) AND (VTOK [L] = '2')
    THEN VERBCL := 128
  ELSE IF (TMP='') AND (VTOK [L] = '2')
    THEN VERBCL := 18
  ELSE IF (TMP='') AND (VTOK [L] = '2')
    THEN VERBCL := 169
  ELSE IF (TMP='') AND (VTOK [L] = '2')
    THEN VERBCL := 141
  ELSE IF (TMP='') AND (VTOK [L] = '2')
    THEN VERBCL := 107
  ELSE IF (TMP='') AND (VTOK [L] = '2')
    THEN VERBCL := 98
  ELSE IF ((TMP='') OR (TMP='')) AND (VTOK [L] = '2')
    THEN VERBCL := 3
  ELSE IF (TMP='') AND (VTOK [L] = '1')
    THEN VERBCL := 3
  ELSE IF ((TMP='') OR (TMP='')) AND (VTOK [L] = '3')
    THEN VERBCL := 3
  ELSE IF (TMP='') AND (VTOK [L] = '2')
    THEN VERBCL := 207
  ELSE IF ( (TMP='') OR (TMP='') OR (TMP='') 
    OR (TMP='') OR (TMP='') OR (TMP='') 
    OR (TMP='') OR (TMP='')  OR (TMP='')
    OR (TMP='') OR (TMP='') OR (TMP='') 
    OR (TMP='') OR (TMP='') OR (TMP='') ) 
    AND (VTOK [L] = '1')
    THEN VERBCL := 246
  ELSE IF ((TMP='') OR (TMP='')) AND (VTOK [L] = '1')
    THEN VERBCL := 247
  ELSE INITVERBCL (TMP, VERBCL, VALID);

  IF NOT VALID
    THEN WRITELN (FNAME, ' ERROR: Unclassified or shifted verb ', 
      TMP, ' at ', HEADLINE); 
END;

{ Codify collocation LINE with number NUM in group }
PROCEDURE CODE_LINE (NUM : INTEGER;
         {=========} LINE : STR115);
  VAR
    LINE1 : STR115;
    I, P, P1, LOW, HIGH, MID : INTEGER;
    FOUND, FOUND1 : BOOLEAN;
    RESULT : RESTYPE;
    SOBSTR, FLEXSTR : STR115;
    TMP : STR11;

BEGIN
  LINE1 := COPY (LINE, 3, LENGTH(LINE)-2);

  WITH PARTARR [NUM] DO
    BEGIN
{ Assigning figurativity (idiomaticity) and style }
      IDI := IDIOM;
      STY := STYL;

{ Extraction of trailing dots if exist }
      IF COPY (LINE1, LENGTH(LINE1)-3, 4) = ' ...'
        THEN
          BEGIN
            ONLYDOT := 4;
            LINE1 := COPY (LINE1, 1, LENGTH(LINE1)-4);
          END;

{ Extraction of leading NE if exist }
      NEG := POS (NE, LINE1) = 1;
      IF NEG
        THEN LINE1 := COPY (LINE1, 4, LENGTH(LINE)-3);
      WHOLINE := LINE1;
{ Find and classify verb }
      P := POS (BL, LINE1);
      TOKN := COPY (LINE1, 1, P-1); { <-- this is verb }
      CLASSIFY_VERB (TOKN, VCLAS);      
      
{ String to be elaborated further is }
      LINE1 := COPY (LINE1, P+1, LENGTH(LINE1)-P);

{ Extraction of reflexive ///... }
      P := POS ('', LINE1) + POS ('', LINE1);
      IF (P > 0) 
        AND (POS (' ', LINE1) = 0)
        AND (POS ('', LINE1) = 0)
        AND (POS ('', LINE1) = 0)
        AND (POS ('', LINE1) = 0)
        THEN
          BEGIN
            REPEAT
              INC (P);
            UNTIL (LINE1 [P] = BL);

            SOBSTR := COPY (LINE1, 1, P-1);
            LINE1 := COPY (LINE1, P+1, LENGTH(LINE1)-P);

            FOUND1 := FALSE;
            I := 0;
            REPEAT 
              INC(I); 
              FOUND1 := (SOBSTR = SOBOJ [I]);
            UNTIL FOUND1 OR (I = 48);

            IF FOUND1
              THEN 
                BEGIN
                  SOBN := I;
                  INC(SOB_COUNT[I]);
                END
              ELSE WRITELN (FNAME, ' ERROR: Wrong reflexive at ',
                HEADER, '=>', LINE);
          END
      ELSE
{ Extraction of compound verb with tail like /... }
        BEGIN
          FOUND1 := FALSE;
          I := 0;
          REPEAT 
            INC(I);
            L1 := LENGTH (VERBTAIL [I]); 
            FOUND1 := (VERBTAIL [I] = COPY (LINE1, 1, L1)) 
              AND (LINE1 [L1+1] = BL);
          UNTIL FOUND1 OR (I = VERBTAILMAX);

          IF FOUND1
            THEN
              BEGIN
                SOBN := I + 100;
                LINE1 := COPY (LINE1, L1+2, LENGTH (LINE1)-L1-1);
              END
            
{ Extraction of compound 	verb with tail  }
          ELSE IF (POS('', LINE1) = 1)
            THEN
              BEGIN
                SOBN := 200;
                LINE1 := COPY (LINE1, 9, LENGTH (LINE1)-8);
              END
          ELSE IF (POS('', LINE1) = 1)
            THEN
              BEGIN
                SOBN := 100;
                LINE1 := COPY (LINE1, 7, LENGTH (LINE1)-6);
              END
{ Extraction of compound verb with tail  
          ELSE IF (POS('', LINE1) = 1)
            THEN
              BEGIN
                SOBN := 150;
                LINE1 := COPY (LINE1, 7, LENGTH (LINE1)-6);
              END }
{ Extraction of compound verb with tail  
          ELSE IF (POS('', LINE1) = 1)
            THEN
              BEGIN
                SOBN := 200;
                LINE1 := COPY (LINE1, 8, LENGTH (LINE1)-7);
              END }
{ Neither reflexive not verb tail }
          ELSE
            BEGIN
              SOBN := 0;
              INC(SOB_COUNT[0]);
            END
        END;

{ Extraction of internal dots }
      IF POS (DOTS, LINE1) = 1
        THEN
          IF ONLYDOT = 4
            THEN WRITELN (FNAME, ' ERROR: Excessive dots at ',
              HEADER, '=>', LINE)
            ELSE ONLYDOT := 3;
      CASE ONLYDOT OF
        1, 2 : LINE1 := COPY (LINE1, 4, LENGTH(LINE1)-3);
        3 : LINE1 := COPY (LINE1, 5, LENGTH(LINE1)-4);
      END;

{ Extraction of simple or compound preposition }
      GCAS := 0;            { Initial hypothesis !!!}
      P := POS (TILDE, LINE1);
      IF P = 0
        THEN
          BEGIN
            WRITELN (FNAME, ' ERROR: Lack of tilde at ',
              HEADER, '=>', LINE);
            EXIT;
          END;
 { Extracting possible preposition }
      PREPSTR := COPY (LINE1, 1, P-2);

{ if (prepstr = '   1')
  then writeln ('found it at ', HEADER); }

 { Is it really among prepositions ? }
IF PREPSTR > DUMMY
  THEN
    BEGIN
      LOW := 8;
      HIGH := MAXPREP;
      FOUND := FALSE;

      WHILE (HIGH >= LOW) AND NOT FOUND DO
        BEGIN
          MID := (HIGH + LOW) DIV 2;
          COMPARE_TOK (PREPSTR, PREPOS [MID].PRP, RESULT);
          CASE RESULT OF
            LT : HIGH := MID - 1;
            EQ : FOUND := TRUE;
            GT : LOW := MID + 1;
          END;
        END;

      IF FOUND
        THEN
          BEGIN
            GCAS := MID;
            INC (PREPO [MID]);
         END
      ELSE
        BEGIN
          LOW := MAXPREP + 4;
          HIGH := MAXPREP2;
          FOUND := FALSE;

          WHILE (HIGH >= LOW) AND NOT FOUND DO
            BEGIN
              MID := (HIGH + LOW) DIV 2;
              COMPARE_TOK (PREPSTR, PREPOS [MID].PRP, RESULT);
              CASE RESULT OF
                LT : HIGH := MID - 1;
                EQ : FOUND := TRUE;
                GT : LOW := MID + 1;
              END;
            END;

          IF FOUND
            THEN
              BEGIN
                GCAS := MID;
                INC (PREPO [MID]);
              END
          ELSE
            BEGIN
              LOW := MAXPREP2 + 1;
              HIGH := MAXPREP3;
              FOUND := FALSE;

              WHILE (HIGH >= LOW) AND NOT FOUND DO
                BEGIN
                  MID := (HIGH + LOW) DIV 2;
                  COMPARE_TOK (PREPSTR, PREPOS [MID].PRP, RESULT);
                  CASE RESULT OF
                    LT : HIGH := MID - 1;
                    EQ : FOUND := TRUE;
                    GT : LOW := MID + 1;
                  END;
               END;
           
              IF FOUND
                THEN
                  BEGIN
                    GCAS := MID;
                    INC (PREPO [MID]);
                  END
              ELSE
                BEGIN
                  LOW := MAXPREP3 + 1;
                  HIGH := MAXPREP4;
                  FOUND := FALSE;

                  WHILE (HIGH >= LOW) AND NOT FOUND DO
                    BEGIN
                      MID := (HIGH + LOW) DIV 2;
                      COMPARE_TOK (PREPSTR, PREPOS [MID].PRP, RESULT);
                      CASE RESULT OF
                        LT : HIGH := MID - 1;
                        EQ : FOUND := TRUE;
                        GT : LOW := MID + 1;
                      END;
                    END;

                  IF FOUND
                    THEN
                      BEGIN
                        GCAS := MID;
                        INC (PREPO [MID]);
                      END
                  ELSE
                    BEGIN
                      LOW := MAXPREP4 + 1;
                      HIGH := MAXPREP5;
                      FOUND := FALSE;

                      WHILE (HIGH >= LOW) AND NOT FOUND DO
                        BEGIN
                          MID := (HIGH + LOW) DIV 2;
                          COMPARE_TOK (PREPSTR, 
                            PREPOS [MID].PRP, RESULT);
                          CASE RESULT OF
                            LT : HIGH := MID - 1;
                            EQ : FOUND := TRUE;
                            GT : LOW := MID + 1;
                          END;
                        END;

                      IF FOUND
                        THEN
                          BEGIN
                            GCAS := MID;
                            INC (PREPO [MID]);
                          END
                      ELSE
                        BEGIN
                          LOW := MAXPREP5 + 1;
                          HIGH := MAXPREP6;
                          FOUND := FALSE;
        
                          WHILE (HIGH >= LOW) AND NOT FOUND DO
                            BEGIN
                              MID := (HIGH + LOW) DIV 2;
                              COMPARE_TOK (PREPSTR, 
                                PREPOS [MID].PRP, RESULT);
                              CASE RESULT OF
                                LT : HIGH := MID - 1;
                                EQ : FOUND := TRUE;
                                GT : LOW := MID + 1;
                              END;
                            END;

                          IF FOUND
                            THEN
                              BEGIN
                                GCAS := MID;
                                INC (PREPO [MID]);
                              END
                          ELSE
                            BEGIN
                              LOW := MAXPREP6 + 1;
                              HIGH := MAXPREP7;
                              FOUND := FALSE;

                              WHILE (HIGH >= LOW) AND NOT FOUND DO
                                BEGIN
                                  MID := (HIGH + LOW) DIV 2;
                                  COMPARE_TOK (PREPSTR, 
                                    PREPOS [MID].PRP, RESULT);
                                  CASE RESULT OF
                                    LT : HIGH := MID - 1;
                                    EQ : FOUND := TRUE;
                                    GT : LOW := MID + 1;
                                  END;
                                END;

                              IF FOUND
                                THEN
                                  BEGIN
                                    GCAS := MID;
                                    INC (PREPO [MID]);
                                  END
                              ELSE
                                BEGIN
                                  LOW := MAXPREP7 + 1;
                                  HIGH := MAXPREP8;
                                  FOUND := FALSE;

                                  WHILE (HIGH >= LOW) AND NOT FOUND DO
                                    BEGIN
                                      MID := (HIGH + LOW) DIV 2;
                                        COMPARE_TOK (PREPSTR, 
                                      PREPOS [MID].PRP, RESULT);
                                      CASE RESULT OF
                                        LT : HIGH := MID - 1;
                                        EQ : FOUND := TRUE;
                                        GT : LOW := MID + 1;
                                      END;
                                    END;
                                
                                  IF FOUND
                                    THEN
                                      BEGIN
                                        GCAS := MID;
                                        INC (PREPO [MID]);
                                      END
                                  ELSE
                                    BEGIN
                                      LOW := MAXPREP8 + 1;
                                      HIGH := MAXPREP9;
                                      FOUND := FALSE;

                                      WHILE (HIGH >= LOW) AND NOT FOUND DO
                                        BEGIN
                                          MID := (HIGH + LOW) DIV 2;
                                          COMPARE_TOK (PREPSTR, 
                                            PREPOS [MID].PRP, RESULT);
                                          CASE RESULT OF
                                            LT : HIGH := MID - 1;
                                            EQ : FOUND := TRUE;
                                            GT : LOW := MID + 1;
                                          END;
                                        END;
           
                                      IF FOUND
                                        THEN
                                          BEGIN
                                            GCAS := MID;
                                            INC (PREPO [MID]);
                                          END
                                      ELSE
                                        BEGIN
                                          LOW := MAXPREP9 + 1;
                                          HIGH := MAXPREP10;
                                          FOUND := FALSE;

                                          WHILE (HIGH >= LOW) AND NOT FOUND DO
                                            BEGIN
                                              MID := (HIGH + LOW) DIV 2;
                                              COMPARE_TOK (PREPSTR, PREPOS [MID].PRP, RESULT);
                                              CASE RESULT OF
                                                LT : HIGH := MID - 1;
                                                EQ : FOUND := TRUE;
                                                GT : LOW := MID + 1;
                                              END;
                                            END;

                                          IF FOUND
                                            THEN
                                              BEGIN
                                                GCAS := MID;
                                                INC (PREPO [MID]);
                                              END
                                          ELSE
                                            BEGIN
                                              LOW := MAXPREP10 + 1;
                                              HIGH := MAXPREP11;
                                              FOUND := FALSE;

                                              WHILE (HIGH >= LOW) AND NOT FOUND DO
                                                BEGIN
                                                  MID := (HIGH + LOW) DIV 2;
                                                  COMPARE_TOK (PREPSTR, 
                                                    PREPOS [MID].PRP, RESULT);
                                                  CASE RESULT OF
                                                    LT : HIGH := MID - 1;
                                                    EQ : FOUND := TRUE;
                                                    GT : LOW := MID + 1;
                                                  END;
                                                END;
                                              
                                              IF FOUND
                                                THEN
                                                  BEGIN
                                                    GCAS := MID;
                                                    INC (PREPO [MID]);
                                                  END
                                              ELSE
                                                BEGIN
                                                  LOW := MAXPREP11 + 1;
                                                  HIGH := MAXPREP12;
                                                  FOUND := FALSE;

                                                  WHILE (HIGH >= LOW) AND NOT FOUND DO
                                                    BEGIN
                                                      MID := (HIGH + LOW) DIV 2;
                                                      COMPARE_TOK (PREPSTR, 
                                                        PREPOS [MID].PRP, RESULT);
                                                      CASE RESULT OF
                                                        LT : HIGH := MID - 1;
                                                        EQ : FOUND := TRUE;
                                                        GT : LOW := MID + 1;
                                                      END;
                                                    END;

                                                  IF FOUND
                                                    THEN
                                                      BEGIN
                                                        GCAS := MID;
                                                        INC (PREPO [MID]);
                                                      END
                                                  ELSE
                                                    BEGIN
                                                      LOW := MAXPREP12 + 1;
                                                      HIGH := MAXPREP13;
                                                      FOUND := FALSE;
                                    
                                                      WHILE (HIGH >= LOW) AND NOT FOUND DO
                                                        BEGIN
                                                          MID := (HIGH + LOW) DIV 2;
                                                          COMPARE_TOK (PREPSTR, PREPOS [MID].PRP, RESULT);
                                                          CASE RESULT OF
                                                            LT : HIGH := MID - 1;
                                                            EQ : FOUND := TRUE;
                                                            GT : LOW := MID + 1;
                                                          END;
                                                        END;

                                                      IF FOUND
                                                        THEN
                                                          BEGIN
                                                            GCAS := MID;
                                                            INC (PREPO [MID]);
                                                          END
                                                      ELSE
{---------------------------------------------------}
                        BEGIN
                          LOW := MAXPREP13 + 1;
                          HIGH := MAXPREP14;
                          FOUND := FALSE;
                        
                          WHILE (HIGH >= LOW) AND NOT FOUND DO
                            BEGIN
                              MID := (HIGH + LOW) DIV 2;
                              COMPARE_TOK (PREPSTR, PREPOS [MID].PRP, RESULT);
                              CASE RESULT OF
                                LT : HIGH := MID - 1;
                                EQ : FOUND := TRUE;
                                GT : LOW := MID + 1;
                              END;
                            END;

                          IF FOUND
                            THEN
                              BEGIN
                                GCAS := MID;
                                INC (PREPO [MID]);
                              END
                          ELSE
                            BEGIN
                              LOW := MAXPREP14 + 1;
                              HIGH := MAXPREP15;
                              FOUND := FALSE;
                           
                              WHILE (HIGH >= LOW) AND NOT FOUND DO
                                BEGIN
                                  MID := (HIGH + LOW) DIV 2;
                                  COMPARE_TOK (PREPSTR, PREPOS [MID].PRP, RESULT);
                                  CASE RESULT OF
                                    LT : HIGH := MID - 1;
                                    EQ : FOUND := TRUE;
                                    GT : LOW := MID + 1;
                                  END;
                                END;

                              IF FOUND
                                THEN
                                  BEGIN
                                    GCAS := MID;
                                    INC (PREPO [MID]);
                                  END
                              ELSE
                                BEGIN
                                  LOW := MAXPREP15 + 1;
                                  HIGH := MAXPREP16;
                                  FOUND := FALSE;
                                  WHILE (HIGH >= LOW) AND NOT FOUND DO
                                  BEGIN
                                    MID := (HIGH + LOW) DIV 2;
                                    COMPARE_TOK (PREPSTR, 
                                      PREPOS [MID].PRP, RESULT);
                                    CASE RESULT OF
                                      LT : HIGH := MID - 1;
                                      EQ : FOUND := TRUE;
                                      GT : LOW := MID + 1;
                                    END;
                                  END;

                                  IF FOUND
                                    THEN
                                      BEGIN
                                        GCAS := MID;
                                        INC (PREPO [MID]);
                                      END
                                  ELSE
                                    BEGIN
                                      LOW := MAXPREP16 + 1;
                                      HIGH := MAXPREP17;
                                      FOUND := FALSE;
                                      WHILE (HIGH >= LOW) AND NOT FOUND DO
                                      BEGIN
                                        MID := (HIGH + LOW) DIV 2;
                                        COMPARE_TOK (PREPSTR, 
                                        PREPOS [MID].PRP, RESULT);
                                        CASE RESULT OF
                                          LT : HIGH := MID - 1;
                                          EQ : FOUND := TRUE;
                                          GT : LOW := MID + 1;
                                        END;
                                      END;

                                      IF FOUND
                                        THEN
                                          BEGIN
                                            GCAS := MID;
                                            INC (PREPO [MID]);
                                          END
                                      ELSE
                                        BEGIN
                                          LOW := MAXPREP17 + 1;
                                          HIGH := MAXPREP18;
                                          FOUND := FALSE;
                                          WHILE (HIGH >= LOW) AND NOT FOUND DO
                                          BEGIN
                                            MID := (HIGH + LOW) DIV 2;
                                            COMPARE_TOK (PREPSTR, 
                                            PREPOS [MID].PRP, RESULT);
                                            CASE RESULT OF
                                              LT : HIGH := MID - 1;
                                              EQ : FOUND := TRUE;
                                              GT : LOW := MID + 1;
                                            END;
                                          END;

                                          IF FOUND
                                            THEN
                                              BEGIN
                                                GCAS := MID;
                                                INC (PREPO [MID]);
                                              END
                                          ELSE 
                                            BEGIN
                                              LOW := MAXPREP18 + 1;
                                              HIGH := MAXPREP19;
                                              FOUND := FALSE;
                                              WHILE (HIGH >= LOW) AND NOT FOUND DO
                                              BEGIN
                                                MID := (HIGH + LOW) DIV 2;
                                                COMPARE_TOK (PREPSTR, 
                                                PREPOS [MID].PRP, RESULT);
                                                CASE RESULT OF
                                                  LT : HIGH := MID - 1;
                                                  EQ : FOUND := TRUE;
                                                  GT : LOW := MID + 1;
                                                END;
                                              END;
      
                                              IF FOUND
                                                THEN
                                                  BEGIN
                                                    GCAS := MID;
                                                    INC (PREPO [MID]);
                                                  END
                                              ELSE 
                                                BEGIN
                                                  LOW := MAXPREP19 + 1;
                                                  HIGH := MAXPREP20;
                                                  FOUND := FALSE;
                                                  WHILE (HIGH >= LOW) AND NOT FOUND DO
                                                  BEGIN
                                                    MID := (HIGH + LOW) DIV 2;
                                                    COMPARE_TOK (PREPSTR, 
                                                    PREPOS [MID].PRP, RESULT);
                                                    CASE RESULT OF
                                                      LT : HIGH := MID - 1;
                                                      EQ : FOUND := TRUE;
                                                      GT : LOW := MID + 1;
                                                    END;
                                                  END;
                                                
                                                  IF FOUND
                                                    THEN
                                                      BEGIN
                                                        GCAS := MID;
                                                        INC (PREPO [MID]);
                                                      END
                                                  ELSE
{------------------------------------------------------------}                                                    
                                                    BEGIN
                                                      LOW := MAXPREP20 + 1;
                                                      HIGH := 
                                                      MAXPREP21;
                                                      FOUND := FALSE;
                                                      WHILE (HIGH >= LOW) AND NOT FOUND DO
                                                      BEGIN
                                                        MID := (HIGH + LOW) DIV 2;
                                                        COMPARE_TOK (PREPSTR, 
                                                        PREPOS [MID].PRP, RESULT);
                                                        CASE RESULT OF
                                                          LT : HIGH := MID - 1;
                                                          EQ : FOUND := TRUE;
                                                          GT : LOW := MID + 1;
                                                        END;
                                                      END;
                                                
                                                      IF FOUND
                                                        THEN
                                                          BEGIN
                                                            GCAS := MID;
                                                            INC (PREPO [MID]);
                                                          END
                                                      ELSE
                                                        BEGIN
                                                          LOW := MAXPREP21 + 1;
                                                          HIGH := MAXPREP22;
                                                          FOUND := FALSE;
                                                          WHILE (HIGH >= LOW) AND NOT FOUND DO
                                                            BEGIN
                                                              MID := (HIGH + LOW) DIV 2;
                                                              COMPARE_TOK (PREPSTR, 
                                                              PREPOS [MID].PRP, RESULT);
                                                              CASE RESULT OF
                                                                LT : HIGH := MID - 1;
                                                                EQ : FOUND := TRUE;
                                                                GT : LOW := MID + 1;
                                                              END;
                                                            END;
                                                          
                                                       {------------}
                                                          IF FOUND
                                                            THEN
                                                              BEGIN
                                                                GCAS := MID;
                                                                INC (PREPO [MID]);
                                                              END
                                                          ELSE
                                                            BEGIN
                                                              LOW := MAXPREP22 + 1;
                                                              HIGH := MAXPREP23;
                                                              FOUND := FALSE;
                                                              WHILE (HIGH >= LOW) AND NOT FOUND DO
                                                                BEGIN
                                                                  MID := (HIGH + LOW) DIV 2;
                                                                  COMPARE_TOK (PREPSTR, 
                                                                  PREPOS [MID].PRP, RESULT);
                                                                  CASE RESULT OF
                                                                    LT : HIGH := MID - 1;
                                                                    EQ : FOUND := TRUE;
                                                                    GT : LOW := MID + 1;
                                                                  END;
                                                                END;
                                                         
                                                              IF FOUND
                                                                 THEN
                                                                   BEGIN
                                                                     GCAS := MID;
                                                                     INC (PREPO [MID]);
                                                                   END
                                                              ELSE
                                                                BEGIN
                                                                  LOW := MAXPREP23 + 1;
                                                                  HIGH := MAXPREP24;
                                                                  FOUND := FALSE;
                                                                  WHILE (HIGH >= LOW) AND NOT FOUND DO
                                                                    BEGIN
                                                                      MID := (HIGH + LOW) DIV 2;
                                                                      COMPARE_TOK (PREPSTR, 
                                                                      PREPOS [MID].PRP, RESULT);
                                                                      CASE RESULT OF
                                                                        LT : HIGH := MID - 1;
                                                                        EQ : FOUND := TRUE;
                                                                        GT : LOW := MID + 1;
                                                                      END;
                                                                    END;

                                                                    IF FOUND
                                                                      THEN
                                                                        BEGIN
                                                                          GCAS := MID;
                                                                          INC (PREPO [MID]);
                                                                        END
                                                                    ELSE 
                                                                      BEGIN
                                                                        LOW := MAXPREP24 + 1;
                                                                        HIGH := MAXPREP25;
                                                                        FOUND := FALSE;
                                                                        WHILE (HIGH >= LOW) AND NOT FOUND DO
                                                                          BEGIN
                                                                            MID := (HIGH + LOW) DIV 2;
                                                                            COMPARE_TOK (PREPSTR, 
                                                                            PREPOS [MID].PRP, RESULT);
                                                                            CASE RESULT OF
                                                                              LT : HIGH := MID - 1;
                                                                              EQ : FOUND := TRUE;
                                                                              GT : LOW := MID + 1;
                                                                            END;
                                                                          END;
                                                                                                                         {===============}
                                                                        IF FOUND
                                                                          THEN
                                                                            BEGIN
                                                                              GCAS := MID;
                                                                              INC (PREPO [MID]);
                                                                            END
                                                                        ELSE 
                                                                           BEGIN
                                                                             LOW := MAXPREP25 + 1;
                                                                             HIGH := MAXPREP26;
                                                                             FOUND := FALSE;
                                                                             WHILE (HIGH >= LOW) AND NOT FOUND DO
                                                                               BEGIN
                                                                                 MID := (HIGH + LOW) DIV 2;
                                                                                 COMPARE_TOK (PREPSTR, 
                                                                                 PREPOS [MID].PRP, RESULT);
                                                                                 CASE RESULT OF
                                                                                   LT : HIGH := MID - 1;
                                                                                   EQ : FOUND := TRUE;
                                                                                   GT : LOW := MID + 1;
                                                                                 END;
                                                                               END;
                                                                                                                         {===============}
                                                                            IF FOUND
                                                                              THEN
                                                                                BEGIN
                                                                                  GCAS := MID;
                                                                                  INC (PREPO [MID]);
                                                                                END
                                                                            ELSE 
                                                                               BEGIN
                                                                                 LOW := MAXPREP26 + 1;
                                                                                 HIGH := MAXPREP27;
                                                                                 FOUND := FALSE;
                                                                                 WHILE (HIGH >= LOW) AND NOT FOUND DO
                                                                                   BEGIN
                                                                                     MID := (HIGH + LOW) DIV 2;
                                                                                     COMPARE_TOK (PREPSTR, 
                                                                                     PREPOS [MID].PRP, RESULT);
                                                                                     CASE RESULT OF
                                                                                       LT : HIGH := MID - 1;
                                                                                       EQ : FOUND := TRUE;
                                                                                       GT : LOW := MID + 1;
                                                                                     END;
                                                                                   END;

                                                                                IF FOUND
                                                                                  THEN
                                                                                    BEGIN
                                                                                      GCAS := MID;
                                                                                      INC (PREPO [MID]);
                                                                                    END
                                                                                ELSE 
                                                                                   BEGIN
                                                                                     LOW := MAXPREP27 + 1;
                                                                                     HIGH := MAXPREP28;
                                                                                     FOUND := FALSE;
                                                                                     WHILE (HIGH >= LOW) AND NOT FOUND DO
                                                                                       BEGIN
                                                                                         MID := (HIGH + LOW) DIV 2;
                                                                                         COMPARE_TOK (PREPSTR, 
                                                                                         PREPOS [MID].PRP, RESULT);
                                                                                         CASE RESULT OF
                                                                                           LT : HIGH := MID - 1;
                                                                                           EQ : FOUND := TRUE;
                                                                                           GT : LOW := MID + 1;
                                                                                         END;
                                                                                       END;
                                                                           
                                                                                     IF FOUND
                                                                                       THEN
                                                                                         BEGIN
                                                                                           GCAS := MID;
                                                                                           INC (PREPO [MID]);
                                                                                         END
                                                                                     ELSE 
                                                                                        BEGIN
                                                                                          LOW := MAXPREP28 + 1;
                                                                                          HIGH := MAXPREP29;
                                                                                          FOUND := FALSE;
                                                                                          WHILE (HIGH >= LOW) AND NOT FOUND DO
                                                                                            BEGIN
                                                                                              MID := (HIGH + LOW) DIV 2;
                                                                                              COMPARE_TOK (PREPSTR, 
                                                                                              PREPOS [MID].PRP, RESULT);
                                                                                              CASE RESULT OF
                                                                                                LT : HIGH := MID - 1;
                                                                                                EQ : FOUND := TRUE;
                                                                                                GT : LOW := MID + 1;
                                                                                              END;
                                                                                            END;
                                                                                    
           										  IF FOUND 
                                                                                            THEN
                                                                                              BEGIN
                                                                                                GCAS := MID;
                                                                                                INC (PREPO [MID]);
                                                                                             END
                                                                                         ELSE 
	                                                                                   WRITELN (FNAME, 
                                                                                             ' ERROR: Wrong preposition at ',
                                                                                             HEADER, '=>', LINE);
                                                                                    END;
                                                                                END;
                                                                            END;    
                                                                        END;        
                                                                    END;            
                                                                END;                
                                                            END;                    
                                                        END;                        
                                                    END;                            
                   { --------------------------------------}                        
                                                END;
                                            END;    
                                        END;
                                    END;
                                END;
                            END;
                        END;
{---------------------------------------------------}
                                                    END;
                                                END;
                                            END;
                                        END;
                                    END;
                                END;
                            END;
                        END;
                    END;                                                                                                                                                                
                END;
            END;
        END;
    END;

{ Extraction of flection }
      FLEXSTR := COPY (LINE1, P+1, LENGTH(LINE1)-P);
      P1 := POS (TILDE, FLEXSTR);
      IF P1 = 0
        THEN
          BEGIN
            IF DOUBLE_FL
              THEN WRITELN (FNAME, ' ERROR: Wrong tildes for ', HEADLINE)
              ELSE
                IF FLEXSTR = DUMMY
                  THEN FLEX := TILDE
                  ELSE FLEX := FLEXSTR;
          END
        ELSE
          BEGIN
            FLEX := COPY (FLEXSTR, 1, P1-2);
            IF FLEX = DUMMY
              THEN FLEX := TILDE;
            FLX1 := COPY (FLEXSTR , P1+1, LENGTH(FLEXSTR)-P1);
            IF FLX1 = DUMMY
              THEN FLX1 := TILDE;
            IF FL_REVERS
              THEN
                BEGIN
                  TMP := FLEX;
                  FLEX := FLX1;
                  FLX1 := TMP;
                END;
          END;
    END;
END;

{ Is TOKEN day number? }
FUNCTION IS_DAY_NUM (TOKEN : STR115) : BOOLEAN;
        {==========}
  CONST
    MAX = 31;
    DAY_TOKENS : ARRAY [1..MAX] OF STRING [2] =
('1','2','3','4','5','6','7','8','9',
'10','11','12','13','14','15','16','17',
'18','19','20','21','22','23','24',
'25','26','27','28','29','30','31');
  VAR
    I : INTEGER;
    FOUND : BOOLEAN;
BEGIN
  FOUND := FALSE;
  I := 0;
  REPEAT
    INC (I);
    FOUND := (TOKEN = DAY_TOKENS [I])
  UNTIL FOUND OR (I = MAX);
  IS_DAY_NUM := FOUND;
END; 

{ Is TOKEN month name? }
FUNCTION IS_MONTH_NAME (TOKEN : STR115) : BOOLEAN;
        {=============}
  CONST
    MAX = 12;
    MONTH_TOKENS : ARRAY [1..MAX] OF STRING [8] =
('','','','','','',
'','','','','','');
  VAR
    I : INTEGER;
    FOUND : BOOLEAN;
BEGIN
  FOUND := FALSE;
  I := 0;
  REPEAT
    INC (I);
    FOUND := (TOKEN = MONTH_TOKENS [I])
  UNTIL FOUND OR (I = MAX);
  IS_MONTH_NAME := FOUND;
END; 

{ Is possible PARtitive case for TOKEN? }
FUNCTION PART_POSSIBLE (TOKEN : STR115) : BOOLEAN;
        {=============}
  CONST
    PARTMAX = 68;
    PART_TOKENS : ARRAY [1..PARTMAX] OF STRING [9] =
('','','','','',
'','','','','','',
'','','','','','',
  '','','',
'','','','','','','','',
'','',
'','','','','','','',
'','','','','','',
  '','','','','','',
'','','','','','',
'','','','','','',
'','','','','','','');
  VAR
    I : INTEGER;
    FOUND : BOOLEAN;
BEGIN
  FOUND := FALSE;
  I := 0;
  REPEAT
    INC (I);
    FOUND := (TOKEN = PART_TOKENS [I])
  UNTIL FOUND OR (I = PARTMAX);
  PART_POSSIBLE := FOUND;
END; 

{ Does verb TOKEN imply DATivness? }
FUNCTION MEANS_DATIV (TOKEN : STR115) : BOOLEAN;
        {===========}
  CONST
    TOKMAX = 184;
    SOME_TOKENS : ARRAY [1..TOKMAX] OF STRING [20] =
 ('',
  '','','','','',
'','','','',
'','','','','',
  '','',
  '','','','','',
'','','','',
'','','','',
'','',
  '',
  '','','','',
'','','','',
'','','',
'','','','',
'','','','',
  '','','','',
  '','',
'','','','','',
  '','','','','',
  '','','',
'','','','','',
  '','','','',
  '','','','',
  '','','','',
  '','','','',
  '','','','',
  '','','','',
  '','','','','',
  '','','','','',
  '','','','',
  '','','','',
  '','','',
  '',{'','',}
  '','','','',
  '','','','',
  '','','','',
  '','','','',
  '','','',
  '','','','',
  '',
  '','','',
  '',
'','','','','',
'','','','',
  '','','','',
  '','','','',
  '','','','',
  '','',
'','','','',
  '','','','',
  '','','');
  VAR
    I : INTEGER;
    FOUND : BOOLEAN;
BEGIN
  FOUND := FALSE;
  I := 0;
  REPEAT
    INC (I);
    FOUND := (SOME_TOKENS [I] = TOKEN);
  UNTIL FOUND OR (I = TOKMAX);
  MEANS_DATIV := FOUND;
END;

{ Does verb TOKEN sometimes mean DATiveness? }
FUNCTION MEANS_DATIV0 (TOKEN : STR115) : BOOLEAN;
        {============}
  CONST
    TOKMAX0 = 12;
    SOME_TOKENS : ARRAY [1..TOKMAX0] OF STRING [20] =
 ('','','','',
  '','','','',
  '','','','');
  VAR
    I : INTEGER;
    FOUND : BOOLEAN;
BEGIN
  FOUND := FALSE;
  I := 0;
  REPEAT
    INC (I);
    FOUND := (SOME_TOKENS [I] = TOKEN);
  UNTIL FOUND OR (I = TOKMAX0);
  MEANS_DATIV0 := FOUND;
END;

{ Does verb TOKEN imply INStrumentality? }
FUNCTION MEANS_INSTR (TOKEN : STR115) : BOOLEAN;
        {===========}
  CONST
    TOKMAX = 158;
    SOME_TOKENS : ARRAY [1..TOKMAX] OF STRING [17] =
('','','',
'','','','',
  '','','',
  '','','','',
  '',
'','','','',
  '','','',
'','','','',
  '','','','',
  '','','','',
  '','',
'','','','','',
'','','','',
'','','','',
'','','','',
  '','','','',
  '','','','',
  '',
'','','','',
  '','','','',
  '','','','',
  '','','','',
  '','','','',
  '','','','',
  '','','',
  '','','','',
  '','','','',
'','','','',
  '','','',
  '','','','',
  '','','','',
  '','','',
'','','','',
  '','',
  '','','',
'','',{'','',}'',
  '','','','',
  '',
'','','','',
'','','','','','',
  '','','','','',
  '','','','',
  '','','','',
  '',
'','');
  VAR
    I : INTEGER;
    FOUND : BOOLEAN;
BEGIN
  FOUND := FALSE;
  I := 0;
  REPEAT
    INC (I);
    FOUND := (SOME_TOKENS [I] = TOKEN);
  UNTIL FOUND OR (I = TOKMAX);
  MEANS_INSTR := FOUND;
END;

{ Verb TOKEN implies GENitivity for PART case }
FUNCTION MEANS_GENIT0 (TOKEN : STR115) : BOOLEAN;
        {============}
  CONST
    TOKMAX = 38;
    SOME_TOKENS : ARRAY [1..TOKMAX] OF STRING [14] =
('','','',
'','','','','',
  '',
'','',
'','','','',
  '','','',' ',
  ' ',
'','','','',
'','','','',
'','','','',
' ','',' ','',
'','');
   VAR
     I : INTEGER;
     FOUND : BOOLEAN;
BEGIN
  I := 0;
  REPEAT
    INC (I);
    FOUND := (SOME_TOKENS [I] = TOKEN);
  UNTIL FOUND OR (I = TOKMAX);
  MEANS_GENIT0 := FOUND;
END;

{ Does verb TOKEN mean GENitivity in general? }
FUNCTION MEANS_GENIT (TOKEN : STR115) : BOOLEAN;
        {===========}
  CONST
    TOKMAX = 39;
    SOME_TOKENS : ARRAY [1..TOKMAX] OF STRING [14] =   
('','',
'','','','',
'','',
'','','','','',
'','','','',
'','','',
  '','','',
'','','','',
'','','',
  '','',
'','','',
'','','','');
   VAR
     I : INTEGER;
     FOUND : BOOLEAN;
BEGIN
  I := 0;
  REPEAT
    INC (I);
    FOUND := (SOME_TOKENS [I] = TOKEN);
  UNTIL FOUND OR (I = TOKMAX);
  MEANS_GENIT := FOUND;
END;

{ Does flection FLEX suit to CASe for header's CLASS? }
FUNCTION SUITED (FLEX : STR11;
        {======} CLASS : INTEGER;
                 CAS : CASUS;
                 VAR GCAS : INTEGER) : BOOLEAN;
BEGIN
  SUITED := FALSE;
  IF FLEX = FINALS [CLASS, CAS]
    THEN
      BEGIN
        SUITED := TRUE;
        GCAS := ORD (CAS);
      END;
END;

{ Assigning general case for collocation
  numbered with NUM in group with header of CLASS }
PROCEDURE ENCODE_ITEM (CLASS : INTEGER;
         {===========} NUM : INTEGER);
VAR
  DONE : BOOLEAN;
  L : INTEGER;
  TOK1 : STR115;
BEGIN
  DONE := FALSE;
  WITH PARTARR [NUM] DO
    BEGIN
      L := LENGTH (TOKN);
      IF (POS (TOKN [L], '123456') > 0)
        THEN TOK1 := COPY (TOKN, 1, L-1)
        ELSE TOK1 := TOKN;

{ Assigning GCAS for ZERO class HEADER } 
      IF (CLASS = 0) AND (GCAS = 0)
        THEN
          BEGIN
            IF MEANS_DATIV (TOK1)
              THEN 
                CASE ONLYDOT OF
                  0, 3 : GCAS := 2;
                  4 : GCAS := 3;
                END
            ELSE IF (MEANS_GENIT (TOK1) OR MEANS_GENIT0 (TOK1))
              THEN 
                CASE ONLYDOT OF
                  0, 4 : GCAS := 1;
                  3 : GCAS := 3;
                END
            ELSE IF MEANS_INSTR (TOK1)
              THEN
                CASE ONLYDOT OF
                  0, 3 : GCAS := 4;
                  4 : GCAS := 3;
                END
            ELSE GCAS := 3;
            DONE := TRUE;
            EXIT;
          END;

 { Assigning GCAS when noun class is FEMINine } 
      IF NOT DONE THEN
        BEGIN
          {IF SUITED (FLEX, CLASS, INS, GCAS)
            AND (FEMIN (CLASS,1) OR FEMIN (CLASS,2)) 
            AND (MEANS_INSTR (TOK1) OR (TOKN = '1')) 
            THEN WRITELN (TOKN, BL, HEADER, BL, FLEX, BL, GCAS);}
 
          IF SUITED (FLEX, CLASS, INS, GCAS) 
            AND (FEMIN (CLASS,1) OR FEMIN (CLASS,2)) 
            AND (MEANS_INSTR (TOK1) OR (TOKN = '1')) 
            THEN 
              BEGIN
                DONE := TRUE;
                EXIT;
              END
          ELSE IF FEMIN (CLASS,1) OR FEMIN (CLASS,2)
            THEN
              BEGIN
                IF (MEANS_DATIV (TOK1) OR MEANS_DATIV0 (TOK1)) 
                  AND (ONLYDOT = 3) AND SUITED (FLEX, CLASS, DAT, GCAS) 
                  THEN DONE := TRUE
                ELSE IF (MEANS_DATIV (TOK1) AND (ONLYDOT = 4)) 
                  OR MEANS_GENIT0 (TOK1) OR MEANS_GENIT (TOK1)
                  AND SUITED (FLEX, CLASS, GEN, GCAS) 
                  THEN DONE := TRUE
                ELSE IF SUITED (FLEX, CLASS, ACC, GCAS) 
                  THEN DONE := TRUE;
              END;
        END;
      
{ Assigning GCAS for other HEADER ("inanimate"?) } 
      IF NOT DONE AND (MEANS_GENIT0 (TOK1) OR MEANS_GENIT0 (TOK1)) 
        AND (ONLYDOT = 4) AND (ANIM0 <> YES)
        AND SUITED (FLEX, CLASS, GEN, GCAS)
        THEN DONE := TRUE
      ELSE IF MEANS_DATIV (TOK1) AND (ANIM0 <> YES)
        AND SUITED (FLEX, CLASS, DAT, GCAS)
        THEN DONE := TRUE
      ELSE IF MEANS_INSTR (TOK1) AND SUITED (FLEX, CLASS, INS, GCAS)
        THEN DONE := TRUE
      ELSE IF NEG OR MEANS_GENIT (TOK1)
        THEN
          BEGIN
            IF SUITED (FLEX, CLASS, GEN, GCAS)
              THEN DONE := TRUE
            ELSE IF SUITED (FLEX, CLASS, ACC, GCAS)
              THEN DONE := TRUE;
          END
        ELSE
          BEGIN
            IF SUITED (FLEX, CLASS, ACC, GCAS)
              THEN DONE := TRUE
            ELSE IF SUITED (FLEX, CLASS, GEN, GCAS)
              THEN DONE := TRUE;
          END;
      IF NOT DONE
        THEN
          BEGIN
            IF SUITED (FLEX, CLASS, DAT, GCAS)
              THEN DONE := TRUE
            ELSE IF SUITED (FLEX, CLASS, INS, GCAS)
              THEN DONE := TRUE;
          END;
      IF NOT DONE
        THEN WRITELN (FNAME, ' ERROR: Wrong flexion for CLASS ',
          CLASS, '=>', HEADER, BL, TOKN, ' ~', FLEX);
    END;
END;

{ Final case encoding for VALIDated noun }
PROCEDURE ENCODE_VALID (CLASS : INTEGER);
         {============}
   VAR
     I : INTEGER;
     DONE : BOOLEAN;

BEGIN
  INC (AMT0);
  INC (AMT);
  FOR I := 1 TO PARTAMT DO
    WITH PARTARR [I] DO
      BEGIN
        IF FLEX = TILDE
          THEN FLEX := FINALS [CLASS, NOM]
        ELSE IF FLEX = '/'
          THEN FLEX := DUMMY;

        IF (GCAS >= 8)
          THEN { Preposition <=> flection test }
            BEGIN
              IF (FINALS [CLASS, PREPOS [GCAS].CAS] <> FLEX)
                THEN WRITELN (FNAME, ' ERROR: Preposition-Flextion dismatch ',
                  HEADER, '=>', TOKN, BL, PREPOS [GCAS].PRP, ' ~', FLEX);
            END
          ELSE { Prepositionless ending test and coding }
            BEGIN
              DONE := FALSE;
              IF PART_POSSIBLE (HEADER)
                AND (COPY (TOKN, 1, 5) <> '')
                AND (COPY (TOKN, 1, 4) <> '')
                AND (COPY (TOKN, 1, 4) <> '')
                AND (COPY (TOKN, 1, 8) <> '')
                AND (COPY (TOKN, 1, 8) <> '')
                AND (COPY (TOKN, 1, 8) <> '')
                AND SUITED (FLEX, CLASS, PAR, GCAS)
                THEN DONE := TRUE;
              IF NOT DONE
                THEN ENCODE_ITEM (CLASS, I);
            END;
      END;
END;

FUNCTION THERE_IS_FLEX (FLEX : STR11;
        {=============} CLASS : INTEGER) : BOOLEAN;
BEGIN
  THERE_IS_FLEX := (FLEX = FINALS [CLASS, GEN])
    OR (FLEX = FINALS [CLASS, DAT])
    OR (FLEX = FINALS [CLASS, ACC])
    OR (FLEX = FINALS [CLASS, INS]);
END;

{ Has CLASS its ANIMCL analogue? }
FUNCTION CAN_BE_ANIMATED (CLASS : INTEGER;
        {===============} VAR ANIMCL : INTEGER) : BOOLEAN;
  VAR
    LOW, HIGH, MID : INTEGER;
    FOUND : BOOLEAN;
BEGIN
  ANIMCL := 0;
  LOW := 1;
  HIGH := MAXANIM;
  FOUND := FALSE;
  WHILE (HIGH >= LOW) AND NOT FOUND DO
    BEGIN
      MID := (HIGH + LOW) DIV 2;
      IF CLASS < FORANIM [MID].CL1
        THEN HIGH := MID - 1
      ELSE IF CLASS = FORANIM [MID].CL1
        THEN FOUND := TRUE
        ELSE LOW := MID + 1;
    END;
  CAN_BE_ANIMATED := FOUND;
  IF FOUND
    THEN ANIMCL := FORANIM [MID].CL2;
 END;

{ Has CLASS its DEANIMCL analogue? }
FUNCTION CAN_BE_DEANIMATED (CLASS : INTEGER;
        {=================} VAR DEANIMCL : INTEGER) : BOOLEAN;
VAR
  I : INTEGER;
  FOUND : BOOLEAN;
BEGIN
  DEANIMCL := CLASS;
  I := 0;
  FOUND := FALSE;
  REPEAT
    INC(I); 
    FOUND := (CLASS = FORANIM [I].CL2);
  UNTIL (I = MAXANIM) OR FOUND;
  CAN_BE_DEANIMATED := FOUND;
  IF FOUND
    THEN DEANIMCL := FORANIM [I].CL1;
END;

{ Delete commnt in header TOK }
FUNCTION CLEANED (TOK : STR115) : STR115;
        {======}
  VAR 
    PQ : INTEGER; 
BEGIN
  PQ := POS ('<', TOK);
  IF PQ > 1
    THEN CLEANED := COPY (TOK, 1, PQ-1)
    ELSE CLEANED := TOK;
END;

{ Final case encoding for INVALidated noun }
PROCEDURE ENCODE_INVAL1 (VAR CLASS : INTEGER;
         {=============} NUMB : NUMBER;
                         GEND : GENDER;
                         ANIM : ANIMA);
  VAR
    ANIMCL, L0 : INTEGER;
    I : INTEGER;
    DONE, OK, HERE_OK, ANIMABLE, HERE_ANIMABLE,
    FEMINABLE, HERE_FEMINABLE,
    MASCULABLE, HERE_MASCULABLE,
    ACCENTABLE, HERE_ACCENTABLE, CBA : BOOLEAN;
    CAS0 : CASUS;

BEGIN
  OK := TRUE;
  CBA := CAN_BE_ANIMATED (CLASS, ANIMCL);
  ANIMABLE := TRUE;
  FEMINABLE := TRUE;
  ACCENTABLE := TRUE;
  MASCULABLE := TRUE;

  FOR I := 1 TO PARTAMT DO
    WITH PARTARR [I] DO
      BEGIN
        L0 := LENGTH (FLEX);
        IF FLEX = TILDE
          THEN FLEX := FINALS [CLASS, NOM]
        ELSE IF FLEX = '/'
          THEN FLEX := DUMMY;
        HERE_MASCULABLE := (CLASS = 41) OR (CLASS = 43)
          OR (CLASS = 45) OR (CLASS = 46) OR (CLASS = 28);

        IF (GCAS >= 8)
          THEN { Test of preposition-flection correspondence }
            BEGIN
              CAS0 := PREPOS [GCAS].CAS;
              HERE_OK := FINALS [CLASS, CAS0] = FLEX;
              HERE_ANIMABLE := NOT HERE_OK AND (ANIM = NO)
                AND (CAS0 = ACC) AND CBA;
              HERE_FEMINABLE := NOT HERE_OK AND (NUMB = PLUR)
                AND (CAS0 = GEN) AND ((FLEX = DUMMY) OR (FLEX = ''));
              HERE_ACCENTABLE := NOT HERE_OK AND (NUMB = SING)
                AND (CAS0 = INS) AND (FLEX [L0-1] = '');
              IF HERE_MASCULABLE
                THEN
                  CASE CAS0 OF
                    NOM, ACC : ;
                    GEN :
                      CASE CLASS OF
                        28 : HERE_MASCULABLE := (FLEX = '');
                        ELSE HERE_MASCULABLE := (FLEX = '');
                      END;
                    DAT, INS, PRE :
                      CASE CLASS OF
                        28 : HERE_MASCULABLE := (FLEX = FINALS [CLASS, CAS0]);
                        41, 43 : HERE_MASCULABLE :=
                          (''+FLEX = FINALS [CLASS, CAS0]);
                        45 : HERE_MASCULABLE :=
                          (''+FLEX = FINALS [CLASS, CAS0]);
                        46 : HERE_MASCULABLE :=
                          (''+FLEX = FINALS [CLASS, CAS0]);
                      END;
                  END;
              IF NOT (HERE_OK OR HERE_ANIMABLE OR HERE_FEMINABLE
                OR HERE_ACCENTABLE OR HERE_MASCULABLE)
                THEN WRITELN (FNAME, ' ERROR: Preposition-Flexion dismatch ',
                  HEADER, '->', TOKN, BL, PREPOS [GCAS].PRP, ' ~', FLEX);
              OK := OK AND HERE_OK;
              ANIMABLE := ANIMABLE AND (HERE_OK OR HERE_ANIMABLE);
              FEMINABLE := FEMINABLE AND (HERE_OK OR HERE_FEMINABLE);
              ACCENTABLE := ACCENTABLE AND (HERE_OK OR HERE_ACCENTABLE);
              MASCULABLE := MASCULABLE AND HERE_MASCULABLE;
            END
          ELSE
            BEGIN
              OK := OK AND THERE_IS_FLEX (FLEX, CLASS);
              ANIMABLE := ANIMABLE AND THERE_IS_FLEX (FLEX, CLASS)
                AND (FLEX <> FINALS [CLASS, ACC]);
              FEMINABLE := FEMINABLE AND (THERE_IS_FLEX (FLEX, CLASS)
                OR (FLEX = '') OR (FLEX = DUMMY))
                AND (FLEX <> FINALS [CLASS, GEN]);
              ACCENTABLE := ACCENTABLE AND (THERE_IS_FLEX (FLEX, CLASS)
                OR (L0 > 1) AND (FLEX [L0-1] = ''))
                AND (FLEX <> FINALS [CLASS, INS]);
              IF HERE_MASCULABLE
                THEN
                  CASE CLASS OF
                    28 : HERE_MASCULABLE := (FLEX = '') OR (FLEX = '')
                      OR (FLEX = '') OR (FLEX = '');
                    ELSE HERE_MASCULABLE :=
                      (FLEX = '') OR (FLEX = '') OR (FLEX = '') OR
                      (CLASS = 45) AND (FLEX = '') OR
                      (CLASS = 46) AND (FLEX = '') OR
                      ((CLASS = 41) OR (CLASS = 43)) AND (FLEX = '');
                  END;
              MASCULABLE := MASCULABLE AND HERE_MASCULABLE;
            END;
      END;

  IF OK
    THEN  { Initial class accepted }
      BEGIN
        INC (AMT);
        INC (AMT11);
        FOR I := 1 TO PARTAMT DO
          WITH PARTARR [I] DO
            IF GCAS = 0
              THEN
                BEGIN
                  DONE := FALSE;
                  IF PART_POSSIBLE (HEADER)
                    AND SUITED (FLEX, CLASS, PAR, GCAS)
                    AND (COPY (TOKN, 1, 5) <> '')
                    AND (COPY (TOKN, 1, 4) <> '')
                    THEN DONE := TRUE;
                  IF NOT DONE
                    THEN ENCODE_ITEM (CLASS, I);
                END;
      END
  ELSE IF ANIMABLE
    THEN  { ANIMCL accepted }
      BEGIN
        INC (AMT12);
        INC (AMT);
        CLASS := ANIMCL;
        IF (PI = 0) AND (PH = 0) AND NOT DOUBLE_FL
          THEN writeln (OUT4, CLASS : 3, BL, CLEANED(headline));
        IF DOUBLE_FL AND CAN_BE_ANIMATED (SUBCL, ANSUBCL)
          THEN SUBCL := ANSUBCL;
        FOR I := 1 TO PARTAMT DO
          WITH PARTARR [I] DO
            IF GCAS = 0
              THEN ENCODE_ITEM (CLASS, I);
      END
  ELSE IF FEMINABLE
    THEN  { "FEMINATED" class accepted }
      BEGIN
{  writeln ('FEMINATED ', headline);}
        INC (AMT13);
        INC (AMT);
        IF (CLASS = 86) OR (CLASS = 88)
          THEN CLASS := 90
        ELSE IF (CLASS = 37) OR (CLASS = 33)
          THEN CLASS := 35
        ELSE IF CLASS = 39
          THEN CLASS := 28
        ELSE IF CLASS = 74
          THEN CLASS := 131
          ELSE WRITELN (FNAME, ' ERROR: Cant feminize class ', CLASS, 
            ' for ', HEADLINE);
        IF (PI = 0) AND (PH = 0) AND NOT DOUBLE_FL
          THEN writeln (OUT4, CLASS : 3, BL, CLEANED(headline));
        FOR I := 1 TO PARTAMT DO
          WITH PARTARR [I] DO
            IF GCAS = 0
              THEN ENCODE_ITEM (CLASS, I);
      END
  ELSE IF MASCULABLE
    THEN  { "MASCULATED" class accepted }
      BEGIN
 { writeln ('MASCULATED ', headline);}
        INC (AMT14);
        INC (AMT);
        IF CLASS = 28
          THEN CLASS := 39
          ELSE CLASS := 37;
        IF (PI = 0) AND (PH = 0) AND NOT DOUBLE_FL
          THEN writeln (OUT4, CLASS : 3, BL, CLEANED(headline));
        FOR I := 1 TO PARTAMT DO
          WITH PARTARR [I] DO
            BEGIN
              IF COPY (FLEX, LENGTH(FLEX)-1, 2) = ''
                THEN FLEX := '';
              IF GCAS = 0
                THEN ENCODE_ITEM (CLASS, I);
            END;
      END
  ELSE IF ACCENTABLE
    THEN  { "ACCENTUATED" CLASS ACCEPTED }
      BEGIN
{   writeln ('ACCENTUATED ', headline); }
        INC (AMT15);
        INC (AMT);
        IF (CLASS = 3) THEN CLASS := 1
        ELSE IF (CLASS = 4) THEN CLASS := 2
        ELSE IF (CLASS = 7) THEN CLASS := 6
        ELSE IF (CLASS = 9) THEN CLASS := 8
        ELSE IF (CLASS = 89) THEN CLASS := 87
        ELSE IF (CLASS = 96) THEN CLASS := 94
        ELSE IF (CLASS = 97) THEN CLASS := 95
        ELSE WRITELN (FNAME, ' ERROR: Cant accentuate class ', CLASS,
          ' for ', HEADLINE);
        FOR I := 1 TO PARTAMT DO
          WITH PARTARR [I] DO
            IF GCAS = 0
              THEN ENCODE_ITEM (CLASS, I);
      END
  ELSE WRITELN (FNAME, ' ERROR: Left undetermined group ', HEADLINE);
END;

PROCEDURE TEST_ENCODE (VAR CLASS : INTEGER;
         {===========} VAR ERROR : BOOLEAN);
  VAR
    I : INTEGER;
BEGIN
  ERROR := FALSE;
  IF CLASS = 0
    THEN
      BEGIN
        FOR I := 1 TO PARTAMT DO
          WITH PARTARR [I] DO
            IF GCAS = 0
              THEN GCAS := 3;       {!}
        EXIT;
      END;
  FOR I := 1 TO PARTAMT DO
    WITH PARTARR [I] DO
      BEGIN
        IF FLEX = TILDE
          THEN FLEX := FINALS [CLASS, NOM]
        ELSE IF FLEX = '/'
          THEN FLEX := DUMMY;

        IF (GCAS >= 8)
          THEN ERROR := ERROR OR
            (FINALS [CLASS, PREPOS [GCAS].CAS] <> FLEX)
          ELSE ENCODE_ITEM (CLASS, I);
      END;
END;

PROCEDURE ENCODE_INVAL2 (VAR CLASS : INTEGER;
         {=============} NUMB : NUMBER;
                         GEND : GENDER;
                         ANIM : ANIMA);
  VAR
    ERROR : BOOLEAN;

BEGIN
  INC (AMT2);
  INC (AMT);
  ERROR := FALSE;

{writeln ('CORRECTED ', headline);}

  CASE CLASS OF
    0 : TEST_ENCODE (CLASS, ERROR);
    6, 8 :
     IF (NUMB = PLUR)
       THEN
         BEGIN
           CLASS := 12;
           TEST_ENCODE (CLASS, ERROR);
           IF ERROR
             THEN
               BEGIN
                 CLASS := 10;
                 TEST_ENCODE (CLASS, ERROR);
               END;
           IF ERROR
             THEN WRITELN (FNAME, ' ERROR: Cannot correct CLASS 6/8 for ',
               HEADLINE);
         END
     ELSE IF (GEND = MASC)
       THEN
         BEGIN
           CLASS := 6;
           TEST_ENCODE (CLASS, ERROR);
           IF ERROR
             THEN WRITELN (FNAME, ' ERROR: Cannot override CLASS 6 for ',
               HEADLINE);
         END;
    9 :
     IF (NUMB = PLUR)
       THEN
         BEGIN
           CLASS := 12;
           TEST_ENCODE (CLASS, ERROR);
           IF ERROR
             THEN WRITELN (FNAME, ' ERROR: Cannot correct CLASS 9 for ',
               HEADLINE);
         END;
    64 :
      BEGIN
        IF (GEND = MASC)
          THEN
            BEGIN
              CLASS := 68;
              TEST_ENCODE (CLASS, ERROR);
              IF ERROR
                THEN
                  BEGIN
                    CLASS := 69;
                    TEST_ENCODE (CLASS, ERROR);
                  END;
            END;
        IF ERROR
          THEN WRITELN (FNAME, ' ERROR: Cannot correct CLASS 64 for ',
            HEADLINE);
      END;
    68 :
      BEGIN
        IF (GEND = FEM)
          THEN
            BEGIN
              CLASS := 64;
              TEST_ENCODE (CLASS, ERROR);
            END;
        IF (GEND <> FEM) OR ERROR
          THEN WRITELN (FNAME, ' ERROR: Cant correct class 68 for ',
            HEADLINE);
      END;
    75 :
      BEGIN
        IF (NUMB = PLUR)
          THEN
            BEGIN
              CLASS := 77;
              TEST_ENCODE (CLASS, ERROR);
            END;
        IF ERROR
          THEN WRITELN (FNAME, ' ERROR: Cant correct class 75 for ',
            HEADLINE);
      END;
    77 :
      BEGIN
        IF (NUMB = SING)
          THEN
            BEGIN
              CLASS := 75;
              TEST_ENCODE (CLASS, ERROR);
            END;
        IF ERROR
          THEN WRITELN (FNAME, ' ERROR: Cant correct class 77 for ',
            HEADLINE);
      END;
    79 :
      BEGIN
        IF (NUMB = SING)
          THEN
            BEGIN
              CLASS := 74;
              TEST_ENCODE (CLASS, ERROR);
            END;
        IF ERROR
          THEN WRITELN (FNAME, ' ERROR: Cant correct class 79 for ',
            HEADLINE);
      END;
    118 :
      BEGIN
        IF (NUMB = SING)
          THEN
            BEGIN
              CLASS := 17;
              TEST_ENCODE (CLASS, ERROR);
            END;
        IF ERROR
          THEN WRITELN (FNAME, ' ERROR: Cant correct class 118 for ',
            HEADLINE);
      END;
    ELSE WRITELN (FNAME, ' ERROR: Wrong agreement or class ', CLASS, ' for ',
      HEADLINE);
  END;
END;

{ Output group content to two output files }
PROCEDURE PARTOUT;
         {=======}
VAR
  CL2 : INTEGER;
  I : INTEGER;
  THEREIS0 : BOOLEAN;

BEGIN
  THEREIS0 := FALSE;
  FOR I := 1 TO PARTAMT DO
    WITH PARTARR [I] DO
      BEGIN
        THEREIS0 := THEREIS0 OR (GCAS = NOGCAS);
        CL2 := 255;
        
        IF (SOBN = 200) 
          AND ((TOKN = '') OR (TOKN = '') OR (TOKN = '')) 
          THEN
            BEGIN
              TOKN := COPY (TOKN,1,LENGTH(TOKN)) + BL + '';
              SOBN := 0;
              CL2 := 0;
            END
       ELSE IF (SOBN = 100) 
          AND ((TOKN = '1') OR (TOKN = '1')) 
          THEN
            BEGIN
              TOKN := COPY (TOKN,1,LENGTH(TOKN)-1) + BL + '';
              SOBN := 0;
              CL2 := 0;
            END
        ELSE IF (SOBN > 100) 
          THEN
            BEGIN
              IF (POS (TOKN[LENGTH(TOKN)], '123456') > 0)
                THEN TOKN := COPY (TOKN,1,LENGTH(TOKN)-1) + BL + VERBTAIL [SOBN-100]
                ELSE TOKN := TOKN + BL + VERBTAIL [SOBN-100];
              SOBN := 0;
              CL2 := 0;
            END
        ELSE IF ((TOKN = '2') OR (TOKN = '') OR
          (TOKN = '') OR (TOKN = '') OR
          (TOKN = '2') OR (TOKN = '2') OR
          (TOKN = '') OR (TOKN = '') OR
          (TOKN = '') OR (TOKN = '') OR 
          (TOKN = '') OR (TOKN = '2') OR 
          (TOKN = '') OR (TOKN = '') OR
          (TOKN = ' ') OR (TOKN = '') OR
          (TOKN = '') OR (TOKN = '') OR 
          (TOKN = '') OR (TOKN = '')) 
          AND (SOBN = 1)
          THEN
            BEGIN
              IF (POS (TOKN[LENGTH(TOKN)], '123456') > 0)
                THEN TOKN := COPY (TOKN, 1, LENGTH(TOKN)-1) + BL + ''
                ELSE TOKN := TOKN + BL + '';
              SOBN := 0;
              CL2 := 0;
            END
        ELSE IF (TOKN = '2') AND (SOBN = 3)
          THEN
            BEGIN
              TOKN := COPY (TOKN,1,LENGTH(TOKN)-1) + BL + '';
              SOBN := 0;
              CL2 := 0;
            END
        ELSE IF (TOKN = '2') AND (SOBN = 6)
          THEN
            BEGIN
              TOKN := COPY (TOKN,1,LENGTH(TOKN)-1) + BL + ' ';
              SOBN := 0;
              CL2 := 0;
            END
        ELSE IF ((TOKN = '1') OR (TOKN = '1'))
          AND (SOBN = 2)
          THEN
            BEGIN
              TOKN := COPY (TOKN,1,LENGTH(TOKN)-1) + BL + '';
              SOBN := 0;
              CL2 := 0;
            END
        ELSE IF ((TOKN = '') OR (TOKN = ''))
          AND (SOBN = 3)
          THEN
            BEGIN
              TOKN := TOKN + BL + '';
              SOBN := 0;
              CL2 := 0;
            END
        ELSE IF ((TOKN = '1') OR (TOKN = '1'))
          AND (SOBN = 15)
          THEN
            BEGIN
              TOKN := COPY (TOKN,1,LENGTH(TOKN)-1) + BL + ' ';
              SOBN := 0;
              CL2 := 0;
            END;
  { Output to file of links }
        IF (TOKN = '1') AND (GCAS = 0)
          THEN GCAS := 3;                          {forcing!}

        IF NEG
          THEN WRITE (OUT, NE);

        WRITELN (OUT, TOKN, BL : GAP - LENGTH(TOKN) - 3 * ORD (NEG) - 1, 
          SOBN : 3, ONLYDOT : 2, GCAS : 5, STY : 2, IDI : 2);  

{ ! SOBN field is widened from 2 to 3, since  only last digit 
    can be read out now by AFG program.        12.11.13, IAB ! }

{  2nd way to cope with is shifting output string 
   to the right by 2 bytes additionally: 
        WRITELN (OUT, TOKN, BL : 17 - LENGTH(TOKN) - 3 * ORD (NEG), 
          SOBN : 3, ONLYDOT : 2, GCAS : 5, STY : 2, IDI : 2);                                                            IAB ! }
          
        IF (GCAS >= 8) AND (GCAS <= MAXPREP29) 
           AND (POS(BL, TOKN) = 0) 
           AND (POS(BL, HEADLINE) = 0)
           AND (POS('-', HEADLINE) = 0)
           AND (POS('^', HEADLINE) = 0)
           THEN
             WITH CASESETS[GCAS] DO
               IF (NOT IN_TOP_32(PREPOS[GCAS].PRP) 
                    AND (EXAMQUAN < MINEXAMPL))
                  OR (IN_TOP_32(PREPOS[GCAS].PRP)
                    AND (EXAMQUAN < MAXEXAMPL) 
                    AND (ONLYDOT = 0))
                 THEN
                   BEGIN
{-----------------}                      
                     INC(EXAMQUAN);

                     QV := LENGTH(TOKN);
                     IF (POS(TOKN[QV],'123456') > 0)
                       THEN TRUNKV := COPY(TOKN, 1, QV-1)
                       ELSE TRUNKV := TOKN;
                     EXAMPLES[EXAMQUAN, 1] := TRUNKV;

                     PREPI := PREPOS[GCAS].PRP;
                     QP := LENGTH(PREPI);
                     IF (POS(PREPI[QP],'123456') > 0)
                       THEN TRUNKP := COPY(PREPI, 1, QP-1)
                       ELSE TRUNKP := PREPI;
                     CASTRING := TRUNKP;
                     
                     QS := POS('<', HEADLINE);
                     IF QS  > 0
                       THEN TRUNKS := COPY(HEADLINE, 1, QS-2)
                       ELSE TRUNKS := HEADLINE;
                     EXAMPLES[EXAMQUAN, 2] := TRUNKS;
                                   
                     INITSUBCL(TRUNKS, CLSI, VALI, NMBI, GNDI, ANMI);
                     
                     EXAMPLES2[EXAMQUAN] := TRUNKV + BL + TRUNKP + BL
                       + COPY(TRUNKS, 1, LENGTH(TRUNKS) - LENGTH(FINALS[CLSI,NOM]))
                       + FINALS[CLSI,PREPOS[GCAS].CAS]; 
{-----------------}                      
                   END; 

{!!!}   IF (GCAS = 0) 
          THEN GCAS := 3;
        IF GCAS < 8
          THEN INC(CAS_WO_PREP [GCAS]);

 { Output to vocabulary file }
        WRITE (OUT2, '2', VCLAS : 4, CL2 : 4, BL);       { IAB ! }
        IF NEG
          THEN WRITE (OUT2, NE);
        WRITELN (OUT2, TOKN);
     END;
  IF THEREIS0
    THEN WRITELN (FNAME, ' ERROR: Zero GENCLASS at ', HEADLINE);
END;

  { Is TOKEN a prepositional phrase? }
  FUNCTION HAS_ADV_PREPOS (TOKEN : STR115) : BOOLEAN;
          {==============}
    CONST
      PREPOSIT : ARRAY [1..36] OF STRING [10] =
        ('','','',
        '','','',{'',}'','',
        '','','','','',
        '','','','',
        '','','','',
        '','','',
        '','','','',
        '','','','','',
        '','','');
    VAR
      I : INTEGER;
      FOUND : BOOLEAN;

  BEGIN
    FOUND := FALSE;
    I := 0;
    REPEAT
      INC (I);
      FOUND := COPY (TOKEN, 1, LENGTH(PREPOSIT [I])+1) 
        = PREPOSIT [I] + BL;
    UNTIL FOUND OR (I = 37);
    HAS_ADV_PREPOS := FOUND;
  END;

  { If TOKEN has adjectival ending, give its number }
PROCEDURE DEFINE_SUFS (TOKEN : STR115;
         {===========} VAR NUM : INTEGER);
  VAR
    I, L : INTEGER;
    FOUND : BOOLEAN;
    FLEX : STR11;
BEGIN
  NUM := 0;
  FOUND := FALSE;
  L := LENGTH (TOKEN);
  I := 0;
  REPEAT
    INC (I);
    FLEX := COPY (TOKEN, L - LENGTH (SUFS [I]) + 1, LENGTH (SUFS [I]));
    FOUND := (SUFS [I] = FLEX);
  UNTIL FOUND OR (I = 53);
  IF FOUND
    THEN NUM := I;
END;


      { Can be TOKEN adjective-like? }
  FUNCTION MAYBE_ADJ (TOKEN : STR115;
          {=========} VAR GEND : GENDER) : BOOLEAN;
    VAR
      LAST : CHAR;
      L, FLEX_NUM : INTEGER;
      VAL : BOOLEAN;

BEGIN
  GEND := NONE;
  IF {(TOKEN = '19') OR (TOKEN = '20') OR (TOKEN = '21')   
    OR} (TOKEN = '^X^I^X') OR (TOKEN = '^X^X') 
    OR (TOKEN = '^X^I^I') OR (TOKEN = '^X^V^I^I^I') 
    OR (TOKEN = '^X^X^I') OR (TOKEN = '101-') 
    OR (TOKEN = '1945-') OR (TOKEN = '37-') 
    OR (TOKEN = '^') OR (TOKEN = '')  
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') {OR (TOKEN = '')}
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '')     
    OR (TOKEN = '^') OR (TOKEN = '^') 
    OR (TOKEN = '') OR (TOKEN = '^')  
    OR (TOKEN = '^') OR (TOKEN = '^') 
    OR (TOKEN = '^') OR (TOKEN = '^') 
    OR (TOKEN = '^') OR (TOKEN = '^') 
    OR (TOKEN = '^') OR (TOKEN = '^') 
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '')OR (TOKEN = '^')  
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '^') OR (TOKEN = '^') 
    OR (TOKEN = '^') OR (TOKEN = '^') 
    OR (TOKEN = '^') OR (TOKEN = '^') 
    OR (TOKEN = '^') OR (TOKEN = '^') 
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '^') 
    OR (TOKEN = '') OR (TOKEN = '^')  
    OR (TOKEN = '^') OR (TOKEN = '^') 
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '^') 
    THEN BEGIN GEND := MASC; VAL := TRUE; END
  ELSE IF (TOKEN = '^') OR (TOKEN = '')
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '^') 
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') 
    OR (TOKEN = '30-') OR (TOKEN = '') 
    THEN BEGIN GEND := FEM; VAL := TRUE; END
  ELSE IF (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '')
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '')OR (TOKEN = '')
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '')  OR (TOKEN = '')
    OR (TOKEN = '') OR (TOKEN = '')
    THEN BEGIN GEND := NEUT; VAL := TRUE; END
  ELSE IF (TOKEN = '^') OR (TOKEN = '')
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '')
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '') OR (TOKEN = '') 
    OR (TOKEN = '20-') OR (TOKEN = '90-')
    THEN BEGIN GEND := COMN; VAL := TRUE; END
  ELSE
  BEGIN
    DEFINE_SUFS (TOKEN, FLEX_NUM);
    IF (FLEX_NUM = 0) OR (FLEX_NUM > 16)
      THEN VAL := FALSE
      ELSE
        BEGIN
          VAL := TRUE;
          CASE FLEX_NUM OF
            1..4 :
              BEGIN
                GEND := MASC;
                L := LENGTH (TOKEN) - LENGTH (SUFS [FLEX_NUM]);
                LAST := TOKEN [L];
                VAL :=
{-/- }    (FLEX_NUM = 1) OR (FLEX_NUM = 4) OR
{- }          (FLEX_NUM = 2) AND ((POS (LAST, AFFR + LABIA) > 0) OR
        (LAST = '') AND (POS (TOKEN [L-1], '') > 0)) OR
{- }          (FLEX_NUM = 3) AND (POS (LAST, '') > 0);
              END;
            5..7, 14 : GEND := FEM;
            8..10, 15 : GEND := NEUT;
            11..13, 16 :
              BEGIN
                GEND := COMN;
                L := LENGTH (TOKEN) - LENGTH (SUFS [FLEX_NUM]);
                LAST := TOKEN [L];
                VAL :=
{-/- }    (FLEX_NUM = 11) OR (FLEX_NUM = 13) OR
{- }          (FLEX_NUM = 12) AND ((POS (LAST, AFFR + LABIA) > 0) OR
        (LAST = '') AND (POS (TOKEN [L-1], '') > 0)) OR
{- }          (FLEX_NUM = 16) AND (POS (LAST, '') > 0);
              END;
          END;
        END;
  END;
  MAYBE_ADJ := VAL;
END;

{ Can be TOKEN as a noun agreed in gender ADJ_GEND? }
FUNCTION MEETS_GEND (TOKEN : STR115;
        {==========} ADJ_GEND : GENDER) : BOOLEAN;
  VAR
    CH : CHAR;
    FIN : STRING [2];
    L0 : INTEGER;

BEGIN
  L0 := LENGTH (TOKEN);
  CH := TOKEN [L0];
  FIN := COPY (TOKEN,L0-1,2);
  MEETS_GEND := FALSE;
  CASE ADJ_GEND OF
    MASC : MEETS_GEND := (POS (CH, ''+ AFFR + LABIA) > 0);
    FEM  : MEETS_GEND := (POS (CH, '') > 0) 
      AND (TOKEN <> '') AND (TOKEN <> '') 
      AND (TOKEN <> '') AND (TOKEN <> '');
    NEUT : MEETS_GEND := (POS (CH, '') > 0) OR (FIN = '');
    COMN : MEETS_GEND := (POS (CH, '') > 0) 
             OR (FIN = '') OR (FIN = '') OR (FIN = '');
  END;
END;

{ Is TOKEN a coordinated pair classified as SING MASC? }
FUNCTION SING_MASC_PAIR (TOKEN : STR115) : BOOLEAN;
        {==============}
CONST
  MAXP = 42;
  PAIRS : ARRAY [1..MAXP] OF STRING [30] =
('  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ',
'  ','  ');
VAR
  I : INTEGER; 
  FOUND : BOOLEAN;
BEGIN
  FOUND := FALSE;
  I := 0;
  REPEAT
    INC(I); 
    FOUND := (TOKEN=PAIRS[I])
  UNTIL FOUND OR (I = MAXP); 
  SING_MASC_PAIR := FOUND;
END;

{ Is TOKEN a coordinated pair classified as SING FEM? }
FUNCTION SING_FEM_PAIR (TOKEN : STR115) : BOOLEAN;
        {=============}
CONST
  MAXP = 5;
  PAIRS : ARRAY [1..MAXP] OF STRING [30] =
('-  ',
'-  ',
'-  ','  ',
'  ');
VAR
  I : INTEGER; 
  FOUND : BOOLEAN;
BEGIN
  FOUND := FALSE;
  I := 0;
  REPEAT
    INC(I); 
    FOUND := (TOKEN=PAIRS[I])
  UNTIL FOUND OR (I = MAXP); 
  SING_FEM_PAIR := FOUND;
END;

{ Is TOKEN a coordinated pair classified as SING NEUT? }
FUNCTION SING_NEUT_PAIR (TOKEN : STR115) : BOOLEAN;
        {==============}
CONST
  MAXP = 3;
  PAIRS : ARRAY [1..MAXP] OF STRING [30] =
('  ','-  ',
'-  ');
VAR
  I : INTEGER; 
  FOUND : BOOLEAN;
BEGIN
  FOUND := FALSE;
  I := 0;
  REPEAT
    INC(I); 
    FOUND := (TOKEN=PAIRS[I])
  UNTIL FOUND OR (I = MAXP); 
  SING_NEUT_PAIR := FOUND;
END;

{ Group coding and output od its header }
PROCEDURE OUT_HEADLINE;
         {============}
BEGIN
  { Coding of whole group with possible correction }
  INC(GRNUM);                                    { DM }
  IF VALID
    THEN ENCODE_VALID (CLASS)
    ELSE
      IF NG_CHANGE
        THEN ENCODE_INVAL2 (CLASS, NUMB0, GEND0, ANIM0)
        ELSE ENCODE_INVAL1 (CLASS, NUMB0, GEND0, ANIM0);
  IF (ANIM0 = YES) AND CAN_BE_ANIMATED (SUBCL, ANIMSUBCL)
    THEN SUBCL := ANIMSUBCL;

  { Output of group header to the file of headers }
  WRITE (OUT1, '1');
  IF (HEADLINE = '  ')
    THEN WRITE (OUT1, '163' : 4, '20' : 4)
  ELSE IF (HEADLINE = '  ')
    THEN WRITE (OUT1, '163' : 4, '61' : 4)
  ELSE IF (HEADLINE = '100 ')
    THEN WRITE (OUT1, '0' : 4, '228' : 4)
  ELSE IF (HEADLINE = ' ')
    THEN WRITE (OUT1, '25' : 4, '41' : 4)
  ELSE IF (COPY(HEADLINE, LENGTH(HEADLINE)-4, 5) = '')
    THEN WRITE (OUT1, CLASS : 4, '329' : 4)
  ELSE IF THERE_IS_VLN OR THERE_IS_H
    THEN WRITE (OUT1, CLASS : 4, SUBCL : 4)
  ELSE IF DOUBLE_FL
    THEN
      BEGIN
        IF FL_REVERS
          THEN WRITE (OUT1, SUBCL : 4, CLASS : 4)
          ELSE WRITE (OUT1, CLASS : 4, SUBCL : 4)
       END
  ELSE WRITE (OUT1, CLASS : 4, '255' : 4);
  
  IF THERE_IS_I 
    THEN
      BEGIN  { Coordinated pair HEADLINE may be singular notion }
        IF SING_MASC_PAIR (HEADLINE)
          THEN BEGIN NUMB0 := SING; GEND0 := MASC; END
        ELSE IF SING_FEM_PAIR (HEADLINE)
          THEN BEGIN NUMB0 := SING; GEND0 := FEM; END
        ELSE IF SING_NEUT_PAIR (HEADLINE)
           THEN BEGIN NUMB0 := SING; GEND0 := NEUT; END
        ELSE BEGIN NUMB0 := PLUR; GEND0 := COMN; END;
      END;

  WRITELN (OUT1, ORD (NUMB0) : 2, ORD (GEND0) : 2, BL, HEADLINE);

  { Output of group header before its group }
  WRITELN (OUT, '+', GRNUM:6, BL, HEADLINE);     { DM }

  IF TOTAL <> AMT
    THEN
      BEGIN
        WRITELN (FNAME, ' ERROR: Something wrong in group ',
          HEADLINE);
        INC (AMT);
      END;
END;

{ Forced animization of single adjective-likes }
FUNCTION ANIMFRCED (TOK : STR115;
        {=========} N : INTEGER) : BOOLEAN;
  CONST            
  T1 : ARRAY [1..45] OF STRING [14] =
('','','','',
'','','','','',
'','','','',
'','','','','',
'','','','',
'','','','','',
'','',
'','','','','',
'','','','',
'','','','',
'','','');

T2 : ARRAY [1..10] OF STR11 =
('','','','','',
'','','','','');

T3 : ARRAY [1..3] OF STR11 =
('','','');

T4 : ARRAY [1..8] OF STR11 =
('','','','','',
'','','');

T5 : ARRAY [1..2] OF STR7 =
('','');

  VAR 
    I, L : INTEGER; 
    FOUND : BOOLEAN;
BEGIN
  FOUND:=FALSE;
  I:=0;
  CASE N OF
    1:L:=45; 2:L:=10; 3:L:=3; 4:L:=8; 5:L:=2;
  END;
  REPEAT
    INC(I);
    FOUND:=(N=1) AND (T1[I]+''=TOK) 
      OR (N=2) AND (T2[I]+''=TOK)
      OR (N=3) AND (T3[I]+''=TOK) 
      OR (N=4) AND (T4[I]+''=TOK) 
      OR (N=5) AND (T5[I]+''=TOK)
  UNTIL FOUND OR(I=L);
  ANIMFRCED:=FOUND;
END;

{ Plural NOUN groups with zero-class initial part }
FUNCTION ZERO_INIT (NOUN : STR115) : BOOLEAN;
        {=========}
CONST
  AMT = 7;
  ZERO_INITS : ARRAY [1..AMT] OF STRING [30] =
(' ',' ',' ',
' ',' ',
' ',' ');
VAR
  I : INTEGER; 
  FOUND : BOOLEAN;
BEGIN
  FOUND := FALSE;
  I := 0;
  REPEAT
    INC(I); 
    FOUND := (NOUN = ZERO_INITS[I]);
  UNTIL FOUND OR (I = AMT); 
  ZERO_INIT := FOUND;
END;

                 { MAIN PROGRAM }
BEGIN 
     { Initiate file of superlong headers }
  VLN_ARRAY_SHORT;
     { Initiate extra-group variables }
  AMT0 := 0;
  AMT11 := 0;
  AMT12 := 0;
  AMT13 := 0;
  AMT14 := 0;
  AMT15 := 0;
  AMT2 := 0;
  AMT := 0;
  TOTAL := 0;
  GRNUM := 1;          { DM }

  FOR J := 8 TO MAXPREP29 DO
    PREPO [J] := 0;
  FOR J := 8 TO MAXPREP29 DO
    WITH CASESETS [J] DO
      FOR D := 0 TO MAXEXAMPL DO
        BEGIN
          EXAMPLES[D,1] := DUMMY;
          EXAMPLES[D,2] := DUMMY;
          EXAMPLES2[D] := DUMMY;
        END;

  FOR I := 1 TO 5 DO
    USECOUNT[I] := 0;
  FOR I := 0 TO 7 DO
    CAS_WO_PREP[I] := 0;
  FOR I := 0 TO 48 DO
    SOB_COUNT[I] := 0;

  FOR J := 8 TO MAXPREP29 DO
    WITH CASESETS [J] DO
      BEGIN
        PREPCODE := J;
        EXAMQUAN := 0;
        CASNAME := PREPOS[J].CAS;
        CASTRING := PREPOS[J].PRP;
        FOR I := 1 TO MAXEXAMPL DO
          BEGIN
            EXAMPLES [I,1] := DUMMY;
            EXAMPLES [I,2] := DUMMY;
          END;         
      END;


    {Open all files}
  ASSIGN (OUT1, 'OPFUNC_0.LST');
  REWRITE (OUT1);

  ASSIGN (OUT2, 'OPFUNC.COD');
  REWRITE (OUT2);

  ASSIGN (OUT3, 'PREPO.LST');
  REWRITE (OUT3);

  ASSIGN (OUT4, 'OPFUNC_A.LST');
  REWRITE (OUT4);

  ASSIGN (OUT5, 'MORFCASE.LST');
  REWRITE (OUT5);

  ASSIGN (OUT6, 'SOBCOUNT.LST');
  REWRITE (OUT6);

  ASSIGN (OUTF, 'VNEXAMPL.TXT');
  REWRITE (OUTF);

  ASSIGN (OUTG, 'VNEXAMPL2.TXT');
  REWRITE (OUTG);

  FOR J := 0 TO 77 DO
    BEGIN
      FNAME := 'OPFUNC' + CHR (ORD ('0') + J DIV 10) +
        CHR (ORD ('0') + J MOD 10) + '.TXT';
      ASSIGN (INP, FNAME);
      RESET (INP);

      FNAMEOUT := COPY (FNAME, 1, LENGTH (FNAME) - 3) + 'COD';
      ASSIGN (OUT, FNAMEOUT);
      REWRITE (OUT);

     { Initiate intra-group variables }
  PARTAMT := 0;
  HEADER := DUMMY;
  SUBHEAD := DUMMY;
  CLASS := 0;
  SUBCL := 0;
  VALID := FALSE;
  SUBVAL := FALSE;
  NUMB0 := UNKN;
  SUBNUMB := UNKN;
  GEND0 := NONE;
  SUBGEND := NONE;
  ANIM0 := IND;
  SUBANIM := IND;
  INIT_ARRAY;
  NG_CHANGE := FALSE;
  DOUBLE_FL := FALSE;
  FL_REVERS := FALSE;
  THERE_IS_I := FALSE;
  THERE_IS_H := FALSE;
  LINENUM := 0;
  PREVHEAD := DUMMY;
  CURHEAD := DUMMY;

    { Main cycle }
  REPEAT
    READLN (INP, LINE);
    WHILE (COPY (LINE, 1 , 2) = '//') DO
      READLN (INP, LINE);

    INC (LINENUM);

    WHILE (LINE [LENGTH (LINE)] = BL) DO
      BEGIN
        WRITELN (FNAME, ' ERROR: Final blank in line ', LINENUM);
        LINE := COPY (LINE, 1, LENGTH (LINE) - 1);
      END;
    FIRST := LINE [1];
    IF (POS (FIRST, 'sqpm*') > 0) OR (POS(TAB,LINE) > 0)
      THEN
        BEGIN
          WRITELN (FNAME, ' ERROR: Wrong label or inner blanks in ', LINENUM);
          HALT;
        END;

    IF (FIRST <> BL) AND (FIRST <> '/') AND (FIRST <> '\') AND (POS('~', LINE) = 0)
      THEN   { Group header }
        BEGIN
          IF PARTAMT > 0
            THEN
              BEGIN
                OUT_HEADLINE;
                PARTOUT;
                PARTAMT := 0;
                INIT_ARRAY;
                NG_CHANGE := FALSE;
                DOUBLE_FL := FALSE;
                FL_REVERS := FALSE;
                THERE_IS_I := FALSE;
                THERE_IS_H := FALSE;
                THERE_IS_VLN := FALSE;
                HEADER := DUMMY;
                SUBHEAD := DUMMY;
              END;

          PK := POS('<', LINE);
          IF PK = 0
            THEN CURHEAD := LINE
            ELSE CURHEAD := COPY (LINE, 1, PK-2);
   
          PU := POS('_', CURHEAD); 
          IF PU > 0
            THEN CURHEAD[PU] := '-';
               
          IF (CURHEAD >= PREVHEAD) 
            THEN PREVHEAD := CURHEAD
            ELSE
              BEGIN
                WRITELN (FNAME, ' ERROR: Wrong header order for ', LINE);
                HALT;
              END;
          
          HEADLINE := LINE;
          THERE_IS_VLN := FALSE;
          IF AMONG_VLN_SHORTS(LINE, NUMB0, GEND0)
            THEN
              BEGIN
                CLASS := 0;     SUBCL := 0; 
                VALID := TRUE;  ANIM0 := IND;
                THERE_IS_VLN := TRUE;
                INC(TOTAL);
              END
          ELSE IF ZERO_INIT(LINE)
            THEN
              BEGIN
                CLASS := 0;
                PB := POS(BL, LINE);
                PART2 := COPY (LINE, PB+1, LENGTH(LINE)-PB); 
                INITSUBCL (PART2, SUBCL, VALID, NUMB0, GEND0, ANIM0);
                IF CAN_BE_ANIMATED (SUBCL, ANCL)
                  THEN SUBCL := ANCL;
                VALID := TRUE; 
                INC (TOTAL);
              END
          ELSE IF (LINE = ' ')
            THEN
              BEGIN
                CLASS := 328;    SUBCL := 329;
                NUMB0 := SING;   GEND0 := MASC;
                ANIM0 := YES;    VALID := TRUE; 
                INC (TOTAL);
              END
          ELSE IF (LINE = ' ')
            THEN
              BEGIN
                CLASS := 179;    SUBCL := 329;
                NUMB0 := SING;   GEND0 := FEM;
                ANIM0 := YES;    VALID := TRUE; 
                INC (TOTAL);
              END
          ELSE IF (LINE = ' ')
            THEN
              BEGIN
                CLASS := 183;    SUBCL := 329;
                NUMB0 := SING;   GEND0 := NEUT;
                ANIM0 := YES;    VALID := TRUE; 
                INC (TOTAL);
              END
          ELSE IF (LINE = ' ')
            THEN
              BEGIN
                CLASS := 163;    SUBCL := 329;
                NUMB0 := PLUR;   GEND0 := COMN;
                ANIM0 := YES;    VALID := TRUE; 
                INC (TOTAL);
              END 
        {  ELSE IF (LINE = ' ')
            THEN
              BEGIN
                CLASS := 0;      SUBCL := 321;       
                NUMB0 := PLUR;   GEND0 := COMN; 
                ANIM0 := YES;    VALID := TRUE; 
              END  }
            
            ELSE
begin
          P := POS ('1', LINE) + POS ('2', LINE) + POS ('3', LINE) +
            POS ('4', LINE) + POS ('5', LINE) + POS ('6', LINE);
          IF (P > 0) AND (POS ('<', LINE) > P)
            THEN LINE := COPY (LINE, 1, P-1);
          PI := POS ('  ', LINE);
          PILI := POS ('  ', LINE);
          IF PI > 1
            THEN
              BEGIN
                THERE_IS_I := TRUE;
                DOUBLE_FL := TRUE;
                FL_REVERS := TRUE;
                SUBHEAD := COPY (LINE, 1, PI-1);
                HEADER := COPY (LINE, PI+3, LENGTH(LINE)-PI-2);
              END
          ELSE IF PILI > 1
            THEN
              BEGIN
                THERE_IS_I := TRUE;
                DOUBLE_FL := TRUE;
                FL_REVERS := TRUE; 
                SUBHEAD := COPY (LINE, 1, PILI-1);
                HEADER := COPY (LINE, PILI+5, LENGTH(LINE)-PILI-4);
              END
            ELSE
              BEGIN
                PH := POS ('_', LINE);
                IF PH > 1
                  THEN
                    BEGIN
                      THERE_IS_H := TRUE;
                      HEADER := COPY (LINE, 1, PH - 1);
                      SUBHEAD := COPY (LINE, PH + 1, LENGTH (LINE) - PH);
                      HEADLINE [PH] := '-';
                    END
                  ELSE
                    BEGIN
                      P := POS (BL, LINE);
                      DOUBLE_FL := (P > 0) {AND (COPY (LINE, 1, P-1) <> ' ')};
                      IF NOT DOUBLE_FL
                        THEN HEADER := LINE
                        ELSE
                          BEGIN
                            TOK1 := COPY (LINE, 1, P-1);
                            TOK2 := COPY (LINE, P+1, LENGTH (LINE) - P);
                            IF (NOT HAS_ADV_PREPOS (TOK2) AND
                              MAYBE_ADJ (TOK1, ADJ_GEND) AND 
                              MEETS_GEND (TOK2, ADJ_GEND))
                              THEN
                                BEGIN
                                  HEADER := TOK2;
                                  SUBHEAD := TOK1;
                                  FL_REVERS := TRUE;
                                END
                              ELSE
                                BEGIN
                                  HEADER := TOK1;
                                  SUBHEAD := TOK2;
                                  FL_REVERS := FALSE;
                                END;
                          END;
                    END;
              END;

      { Classify deviant homonyms}
        IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 86;    VALID := TRUE;
              NUMB0 := PLUR;  GEND0 := COMN;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF ((HEADER = '') OR (HEADER = '')) 
          AND (LINE [LENGTH (HEADER) + 1] = '1')
          THEN
            BEGIN
              CLASS := 37;     VALID := TRUE;
              NUMB0 := PLUR;   GEND0 := COMN;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '1');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 0;      VALID := TRUE;
              NUMB0 := SING;   GEND0 := MASC;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '3')
          THEN
            BEGIN
              CLASS := 35;     VALID := TRUE;
              NUMB0 := PLUR;   GEND0 := COMN;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '3');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 41;    VALID := TRUE;
              NUMB0 := PLUR;  GEND0 := COMN;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF ((HEADER = '^') OR (HEADER = '^')
          OR (HEADER = '^')) AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 1;      VALID := TRUE;
              NUMB0 := SING;   GEND0 := MASC;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '')
          AND (LINE [LENGTH (HEADER) + 1] = '3')
          THEN
            BEGIN
              CLASS := 96;     VALID := TRUE;
              NUMB0 := SING;   GEND0 := MASC;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '3');
            END
        ELSE IF ((HEADER = '') OR (HEADER = '')) 
          AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 8;      VALID := TRUE;
              NUMB0 := SING;   GEND0 := MASC;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 6;      VALID := TRUE;
              NUMB0 := SING;   GEND0 := MASC;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF ((HEADER = '') OR (HEADER = ''))  
          AND (LINE [LENGTH (HEADER) + 1] = '1')
          THEN
            BEGIN
              CLASS := 42;    VALID := TRUE;
              NUMB0 := PLUR;  GEND0 := COMN;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '1');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '4')
          THEN
            BEGIN
              CLASS := 42;    VALID := TRUE;
              NUMB0 := PLUR;  GEND0 := COMN;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '4');
            END
        ELSE IF ((HEADER = '') OR (HEADER = ''))
          AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 42;     VALID := TRUE;
              NUMB0 := PLUR;   GEND0 := COMN;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '')
          AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 176;    VALID := TRUE;
              NUMB0 := PLUR;   GEND0 := COMN;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 163;    VALID := TRUE;
              NUMB0 := PLUR;   GEND0 := COMN;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '1')
          THEN
            BEGIN
              CLASS := 6;      VALID := TRUE;
              NUMB0 := SING;   GEND0 := FEM;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '1');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 6;      VALID := TRUE;
              NUMB0 := SING;   GEND0 := MASC;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 6;      VALID := TRUE;
              NUMB0 := SING;   GEND0 := FEM;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') {OR (HEADER = '')}
          AND (LINE [LENGTH (HEADER) + 1] = '1')
          THEN
            BEGIN
              CLASS := 8;      VALID := TRUE;
              NUMB0 := SING;   GEND0 := MASC;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '1');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 91;     VALID := TRUE;
              NUMB0 := PLUR;   GEND0 := COMN;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END                
        ELSE IF ((HEADER = '') OR (HEADER = ''))
          AND (LINE [LENGTH (HEADER) + 1] = '1')
          THEN
            BEGIN
              CLASS := 42;     VALID := TRUE;
              NUMB0 := PLUR;   GEND0 := COMN;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '1');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '1')
          THEN
            BEGIN
              CLASS := 87;     VALID := TRUE;
              NUMB0 := PLUR;   GEND0 := COMN;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '1');
            END
        ELSE IF ((HEADER = '') OR (HEADER = ''))
          AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 90;      VALID := TRUE;
              NUMB0 := PLUR;    GEND0 := COMN;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 35;     VALID := TRUE;
              NUMB0 := PLUR;   GEND0 := COMN;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF ((HEADER = '') OR (HEADER = '')) 
          AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 1;      VALID := TRUE;
              NUMB0 := SING;   GEND0 := MASC;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 187;        VALID := TRUE;
              NUMB0 := SING;       GEND0 := MASC;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 68;         VALID := TRUE;
              NUMB0 := SING;       GEND0 := MASC;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF ((HEADER = '') OR (HEADER = '^')) 
          AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 1;      VALID := TRUE;
              NUMB0 := SING;   GEND0 := MASC;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF ((HEADER = '') OR (HEADER = ''))
          AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 6;      VALID := TRUE;
              NUMB0 := SING;   GEND0 := MASC;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '3')
          THEN
            BEGIN
              CLASS := 0;      VALID := TRUE;
              NUMB0 := SING;   GEND0 := NEUT;
              ANIM0 := IND;
              writeln (OUT4, CLASS : 3, BL, HEADER + '3');
            END
        ELSE IF ((HEADER = '') OR (HEADER = ''))
          AND (LINE [LENGTH (HEADER) + 1] = '4')
          THEN
            BEGIN
              CLASS := 38;     VALID := TRUE;
              NUMB0 := PLUR;   GEND0 := COMN;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '4');
            END
        ELSE IF ( (HEADER='') OR (HEADER='')
          OR (HEADER='') OR (HEADER='')
          OR (HEADER='') OR (HEADER='')
          OR (HEADER='') OR (HEADER='')
          OR (HEADER='') OR (HEADER='') 
          OR (HEADER='') OR (HEADER='')
          OR (HEADER='') OR (HEADER='')
          OR (HEADER='') OR (HEADER='') 
          OR (HEADER='') OR (HEADER='^^')
          OR (HEADER='') OR (HEADER='')
          OR (HEADER='^^^') OR (HEADER='^^^')
          OR (HEADER='^^^') )
          AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 0;     VALID := TRUE;
              NUMB0 := PLUR;  GEND0 := COMN;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF ((HEADER = '') 
          OR (HEADER = '-') 
          OR (HEADER = ''))
          AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 0;      VALID := TRUE;
              NUMB0 := SING;   GEND0 := FEM;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF ((HEADER = '') OR (HEADER = ''))
          AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 0;     VALID := TRUE;
              NUMB0 := SING;  GEND0 := NEUT;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '^^^')
          AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 0;     VALID := TRUE;
              NUMB0 := SING;  GEND0 := MASC;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '')
          AND (LINE [LENGTH (HEADER) + 1] = '3')
          THEN
            BEGIN
              CLASS := 16;    VALID := TRUE;
              NUMB0 := SING;  GEND0 := NEUT;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 40;    VALID := TRUE;
              NUMB0 := PLUR;  GEND0 := COMN;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF ((HEADER = '') OR (HEADER = '')) 
          AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 38;    VALID := TRUE;
              NUMB0 := PLUR;  GEND0 := COMN;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 11;    VALID := TRUE;
              NUMB0 := PLUR;  GEND0 := COMN;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 12;   VALID := TRUE;
              NUMB0 := PLUR; GEND0 := COMN;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 204;   VALID := TRUE;
              NUMB0 := PLUR;  GEND0 := COMN;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '1')
          THEN
            BEGIN
              CLASS := 12;    VALID := TRUE;
              NUMB0 := PLUR;  GEND0 := COMN;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '1');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '1')
          THEN
            BEGIN
              CLASS := 10;    VALID := TRUE;
              NUMB0 := PLUR;  GEND0 := COMN;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER + '1');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 8;     VALID := TRUE;
              NUMB0 := SING;  GEND0 := FEM;
              ANIM0 := IND;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF ((HEADER = '') OR (HEADER = ''))
          AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 8;    VALID := TRUE;
              NUMB0 := SING; GEND0 := MASC;
              ANIM0 := IND;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF ((HEADER = '^') OR (HEADER = '^')) 
        AND (LINE [LENGTH (HEADER) + 1] = '2')
          THEN
            BEGIN
              CLASS := 2;    VALID := TRUE;
              NUMB0 := SING; GEND0 := MASC;
              ANIM0 := YES;
              writeln (OUT4, CLASS : 3, BL, HEADER + '2');
            END
        ELSE IF ((HEADER = '') OR (HEADER = ''))
          AND (LINE [LENGTH(HEADER)+1] = '3')
          THEN
            BEGIN
              CLASS := 6;    VALID := TRUE;
              NUMB0 := SING; GEND0 := MASC;
              ANIM0 := IND;
              writeln (OUT4, CLASS : 3, BL, HEADER + '3');
            END
        ELSE IF (HEADER = '') AND (LINE [LENGTH(HEADER)+1] = '3')
          THEN
            BEGIN
              CLASS := 90;   VALID := TRUE;
              NUMB0 := PLUR; GEND0 := COMN;
              ANIM0 := NO;
              writeln (OUT4, CLASS : 3, BL, HEADER+'3');
            END
        ELSE IF (HEADER = '^^^')
          THEN
            BEGIN
              CLASS := 86;   VALID := TRUE;
              NUMB0 := PLUR; GEND0 := COMN;
              ANIM0 := NO;
            END
        ELSE IF (AMONG_NUMERALS(HEADER, ERC) = BIG1)
          THEN
            BEGIN
              NUMB0 := PLUR; GEND0 := COMN; 
              ANIM0 := YES; VALID := TRUE;
              IF (HEADER = '') OR (HEADER = '')
                THEN CLASS := 208
                ELSE CLASS := 207;
            END
        ELSE INITSUBCL (HEADER, CLASS, VALID, NUMB0, GEND0, ANIM0);

        SUBCL := 255;

{!}     IF THERE_IS_H
          THEN 
            BEGIN
              INITSUBCL (HEADER, CLASS, VALID, NUMB0, GEND0, ANIM0);
              INITSUBCL (SUBHEAD, SUBCL, SUBVAL, SUBNUMB,
                 SUBGEND, SUBANIM);  

              IF (HEADER = '') AND (SUBHEAD = '')
                 THEN SUBCL := 2; 
              IF (HEADER = '')
                THEN
                  BEGIN
                    CLASS := 91;
                    IF (SUBHEAD = '')
                      THEN SUBCL := 87; 
                  END;
              IF (HEADER = '') AND (SUBHEAD = '')
                THEN SUBCL := 86;
              IF ((HEADER = '') AND (SUBHEAD = ''))
                OR ((HEADER = '') AND (SUBHEAD = ''))
                THEN SUBCL := 1;
              IF (HEADER = '') AND (SUBHEAD = '')
                 THEN SUBCL := 1; 
              IF (HEADER = '') 
                AND ((SUBHEAD = '') OR (SUBHEAD = ''))
                 THEN SUBCL := 68; 
              IF (HEADER = '') 
                AND ((SUBHEAD = '') OR (SUBHEAD = ''))
                 THEN SUBCL := 30; 
              IF (HEADER = '') AND (SUBHEAD = '')
                 THEN SUBCL := 59; 
              IF (HEADER = '') AND (SUBHEAD = '')
                 THEN BEGIN CLASS := 27; SUBCL := 0; END;

              IF (SUBHEAD = '') OR (SUBHEAD = '')
                OR (SUBHEAD = '') OR (SUBHEAD = '')
                OR (SUBHEAD = '') OR (SUBHEAD = '')
                THEN { Both parts are to be animated }
                  BEGIN 
                    IF CAN_BE_ANIMATED (CLASS, ANCL) THEN CLASS := ANCL;
                    IF CAN_BE_ANIMATED (SUBCL, ANCL) THEN SUBCL := ANCL;
                  END;
 
              IF (HEADER = '') OR (SUBHEAD = '')
                 THEN BEGIN CLASS := 146; SUBCL := 87; END;

              IF (HEADER = '') AND (SUBHEAD = '')
                 THEN BEGIN CLASS := 62; SUBCL := 69; END;
 
              IF (SUBHEAD = '') OR (SUBHEAD = '') 
                THEN SUBCL := 0;
            

             { IF ((TOK1 = '') OR (TOK1 = ''))
                   AND (TOK2 = '')
                THEN
                  BEGIN
                    NUMB0 := PLUR; GEND0 := COMN; ANIM := YES;
                    SUBCL := 208;  CLASS := 233;
                    EXIT;
                  END;
              
              IF ((TOK1 = '') OR (TOK1 = ''))
                   AND (TOK2 = '')
                THEN
                  BEGIN
                    NUMB0 := PLUR; GEND0 := COMN; ANIM := YES;
                    SUBCL := 207;  CLASS := 233;
                    EXIT;
                  END;  }
            END;

        IF DOUBLE_FL
          THEN
            BEGIN
              IF FL_REVERS
                THEN 
                  BEGIN
                    IF (TOK2 = '') AND 
                     ( (TOK1 = '') OR (TOK1 = '') 
                     OR (TOK1 = '') OR (TOK1 = '')
                     OR (TOK1 = '') OR (TOK1 = '') 
                     OR (TOK1 = '') 
                     OR (TOK1 = '') OR (TOK1 = '') )
                      THEN
                        BEGIN
                          SUBCL := 118;   CLASS := 287;
                          VALID := TRUE;  NUMB0 := PLUR;
                          GEND0 := COMN;  ANIM0 := NO;
                       END
                    ELSE IF (TOK2 = '') 
                      AND ( (TOK1 = '') OR (TOK1 = '') 
                      OR (TOK1 = '')OR (TOK1 = '') 
                      OR (TOK1 = '') OR (TOK1 = '') ) 
                      THEN 
                        BEGIN 
                          SUBCL := 25;    CLASS := 287; 
                          VALID := TRUE;  NUMB0 := PLUR;
                          GEND0 := COMN;  ANIM0 := NO;
                        END
                    ELSE IF (TOK2 = '') AND (TOK1 = '') 
                      THEN 
                        BEGIN 
                          SUBCL := 169;   CLASS := 287; 
                          VALID := TRUE;  NUMB0 := PLUR;
                          GEND0 := COMN;  ANIM0 := NO;
                        END
                    ELSE IF (TOK1 = '') AND (TOK2 = '')
                      THEN
                        BEGIN
                          SUBCL := 1;      CLASS := 0;
                          VALID := TRUE;   NUMB0 := SING;
                          GEND0 := MASC;   ANIM0 := NO;
                        END
                   ELSE IF (TOK1 = '') AND (TOK2 = '')
                     THEN
                       BEGIN
                         SUBCL := 17;     CLASS := 0;
                         VALID := TRUE;   NUMB0 := SING;
                         GEND0 := NEUT;   ANIM0 := NO;
                       END
                 {   ELSE IF ((TOK1 = '2') OR (TOK1 = '3') OR (TOK1 = '4'))
                      AND (TOK2 = '/')
                      THEN
                        BEGIN
                          SUBCL := 0;      CLASS := 0;
                          VALID := TRUE;   NUMB0 := SING;
                          GEND0 := NEUT;   ANIM0 := NO;
                        END  }
                    ELSE IF (TOK1 = '^') AND (TOK2 = '')
                      THEN
                        BEGIN
                          SUBCL := 119;    CLASS := 1;
                          VALID := TRUE;   NUMB0 := SING;
                          GEND0 := MASC;   ANIM0 := NO;
                        END
                     ELSE IF (TOK1 = '') AND (TOK2 = '') 
                       THEN 
                         BEGIN 
                           SUBCL := 25;    CLASS := 35; 
                           VALID := TRUE;  NUMB0 := PLUR;
                           GEND0 := COMN;  ANIM0 := NO;
                         END
                     ELSE IF (TOK1 = '') AND (TOK2 = '') 
                       THEN 
                         BEGIN 
                           SUBCL := 25;    CLASS := 90; 
                           VALID := TRUE;  NUMB0 := PLUR;
                           GEND0 := COMN;  ANIM0 := NO;
                         END
                     ELSE IF (TOK1 = '') AND (TOK2 = '') 
                       THEN 
                         BEGIN 
                           SUBCL := 163;   CLASS := 27; 
                           VALID := TRUE;  NUMB0 := PLUR;
                           GEND0 := COMN;  ANIM0 := YES;
                         END
                     ELSE IF (TOK1 = '') AND (TOK2 = '') 
                        THEN 
                          BEGIN 
                            SUBCL := 25;    CLASS := 86; 
                            VALID := TRUE;  NUMB0 := PLUR;
                            GEND0 := COMN;  ANIM0 := NO;
                          END
                    ELSE IF (TOK1 = '') AND (TOK2 = '') 
                      THEN 
                        BEGIN 
                          SUBCL := 119;   CLASS := 1; 
                          VALID := TRUE;  NUMB0 := SING;
                          GEND0 := MASC;  ANIM0 := NO;
                        END
                    ELSE IF (TOK1 = '') AND (TOK2 = '')
                      THEN
                        BEGIN
                           SUBCL := 118;   CLASS := 28;   
                           VALID := TRUE;  NUMB0 := PLUR;
                           GEND0 := COMN;  ANIM0 := NO;
                        END
                    ELSE IF (TOK1 = '') AND (TOK2 = '')
                      THEN
                        BEGIN
                           SUBCL := 27;    CLASS := 87;   
                           VALID := TRUE;  NUMB0 := PLUR;
                           GEND0 := COMN;  ANIM0 := NO;
                        END
                    ELSE IF (TOK1 = '') AND (TOK2 = '')
                      THEN
                        BEGIN
                          SUBCL := 199;    CLASS := 90;
                          VALID := TRUE;   NUMB0 := PLUR;
                          GEND0 := COMN;   ANIM0 := NO;
                        END 
                   ELSE IF ((TOK1 = '') OR (TOK1 = '')) 
                     AND (TOK2 = '')
                     THEN
                        BEGIN
                          SUBCL := 26;    CLASS := 146;
                          VALID := TRUE;   NUMB0 := PLUR;
                          GEND0 := COMN;   ANIM0 := YES;
                      END 
                   ELSE IF (TOK2 = '') AND 
                     ((TOK1 = '') OR (TOK1 = ''))
                      THEN
                        BEGIN
                          SUBCL := 26;    CLASS := 26;
                          VALID := TRUE;  NUMB0 := PLUR;
                          GEND0 := COMN;  ANIM0 := YES;
                       END
                    ELSE IF (TOK1 = '^')
                      THEN
                        BEGIN
                          SUBCL := 6;     CLASS := 128;
                          VALID := TRUE;  NUMB0 := SING;
                          GEND0 := MASC;  ANIM0 := YES;
                        END
                    ELSE INITSUBCL (SUBHEAD, SUBCL, SUBVAL, 
                      SUBNUMB, SUBGEND, SUBANIM);
                  END
              ELSE IF IS_DAY_NUM (TOK1) AND IS_MONTH_NAME (TOK2)
                THEN          
                  BEGIN 
                    CLASS := 0; SUBCL := 0;
                    NUMB0 := SING; GEND0 := NEUT; 
                  END
              ELSE IF (AMONG_NUMERALS(TOK1, ERC) = BIG1) AND (ERC = 0) AND
                (  (TOK2 = '') OR (TOK2 = '') OR (TOK2 = '')
                OR (TOK2 = '')  OR (TOK2 = '')  OR (TOK2 = '') 
                OR (TOK2 = '')   OR (TOK2 = '')   OR (TOK2 = '')
                OR (TOK2 = '')  OR (TOK2 = '')  OR (TOK2 = '') 
                OR (TOK2 = '') OR (TOK2 = '')
                OR (TOK2 = '') OR (TOK2 = '') OR (TOK2 = '')
                OR (TOK2 = '')    OR (TOK2 = '')    OR (TOK2 = '') )
                THEN
                  BEGIN
                    CLASS := 0; SUBCL := 228;
                    NUMB0 := PLUR; GEND0 := COMN; 
                  END
              ELSE IF (TOK1 = '') AND (TOK2 = '')
                THEN
                  BEGIN
                    CLASS := 0;    SUBCL := 321;       
                    NUMB0 := PLUR; GEND0 := COMN; 
                  END  
              ELSE IF (AMONG_NUMERALS(TOK1, ERC) = BIG1)
                THEN
                  IF (TOK2 = '')
                    THEN
                      BEGIN
                        NUMB0 := PLUR; GEND0 := COMN; 
                        ANIM := YES;   SUBCL := 233;
                        IF ((TOK1 = '') OR (TOK1 = ''))
                          THEN CLASS := 208
                        ELSE IF ((TOK1 = '') OR (TOK1 = ''))
                          THEN CLASS := 207
                        ELSE 
                          BEGIN
                            WRITELN ('ERROR: Correct the number of ');
                            HALT;
                          END;
                      END
                 ELSE
                   BEGIN
                     NUMB0 := SING; GEND0 := NEUT;
                     INITSUBCL (TOK2, SUBCL, VALID, NUMB0, GEND0, ANIM);
                     IF ((SUBCL = 258) OR (SUBCL =228) OR (SUBCL =229) OR (SUBCL =233)) 
                       AND (ANIM = NO)
                       THEN
                         IF (TOK1 = '') OR (TOK1 = '')
                           THEN CLASS := 305
                           ELSE CLASS := 289
                     ELSE IF ((SUBCL = 258) OR (SUBCL =227) OR (SUBCL =228) 
                       OR (SUBCL =229) OR (SUBCL =284) OR (SUBCL =233) 
                       OR (SUBCL =239) OR (SUBCL =259) OR (SUBCL =306) OR (SUBCL =307)) 
                       AND (ANIM = YES)
                       THEN  
                         IF (TOK1 = '') OR (TOK1 = '')
                           THEN CLASS := 208
                           ELSE CLASS := 207;
                   END
              ELSE IF (AMONG_NUMERALS(TOK2, ERC) = BIG1)
                THEN
                  BEGIN
                    NUMB0 := PLUR; GEND0 := COMN; ANIM := YES;
                    IF (TOK2 = '') OR (TOK2 = '')
                      THEN SUBCL := 208
                      ELSE SUBCL := 207;
                    IF (TOK1 = '')
                      OR (TOK1 = '') OR (TOK1 = '') 
                      OR (TOK1 = '') OR (TOK1 = '')
                      THEN CLASS := 163
                    ELSE IF (COPY (TOK1, LENGTH(TOK1)-1, 2) = '')
                      THEN CLASS := 26
                    ELSE IF (COPY (TOK1, LENGTH(TOK1)-1, 2) = '')
                      THEN CLASS := 27
                    ELSE WRITELN ('ERROR: Collocation uncodable');
                  END
              
           
              ELSE IF (AMONG_NUMERALS(TOK1, ERC) = BIG2) 
                THEN
                  BEGIN
                    NUMB0 := SING; GEND0 := NEUT;
                    IF (ERC = 0)
                      THEN
                        BEGIN
                          CLASS := 0;
                          IF ( (TOK2 = '') OR (TOK2 = '') 
                              OR (TOK2 = '')
                            OR (TOK2 = '') OR (TOK2 = '')
                              OR (TOK2 = '') 
                            OR (TOK2 = '') OR (TOK2 = '')   
                              OR (TOK2 = '')
                            OR (TOK2 = '')  OR (TOK2 = '')  
                              OR (TOK2 = '') 
                            OR (TOK2 = '') OR (TOK2 = '')
                            OR (TOK2 = '') OR (TOK2 = '') 
                              OR (TOK2 = '')
                            OR (TOK2 = '') OR (TOK2 = '') 
                              OR (TOK2 = '') )
                            THEN
                              BEGIN 
                                SUBCL := 228;
                                NUMB0 := PLUR; GEND0 := COMN; 
                              END
                            ELSE INITSUBCL (TOK1, CLASS, VALID, NUMB, GEND, ANIM);
                        END;
                    IF (TOK2 = '')   
                      THEN SUBCL := 238          { </30>  }
                    ELSE IF (TOK2 = '') OR (TOK2 = '') 
                      OR (TOK2 = '') OR (TOK2 = '') 
                      OR (TOK2 = '')  
                      THEN SUBCL := 304          { <200>  }
                    ELSE IF (TOK2 = '') OR (TOK2 = '')  
                      OR (TOK2 ='') OR (TOK2 = '') 
                      THEN SUBCL := 322     { <> / }
                    ELSE IF (TOK2 = '')    
                      THEN SUBCL := 270          { <>  }
                    ELSE IF (TOK2 = '') OR (TOK2 = '') 
                      OR (TOK2 = '') OR (TOK2 = '') 
                      THEN SUBCL := 228
                    ELSE IF (TOK2 = '') OR (TOK2 = '') 
                      OR ((TOK1 = '12') OR (TOK1 = '')) 
                      AND (TOK2 = '')
                      THEN SUBCL := 0
                      ELSE INITSUBCL (TOK2, SUBCL, VALID, 
                        NUMB, GEND, ANIM0);
                  END
              ELSE IF (AMONG_NUMERALS(TOK1, ERC) = SMALL) 
                THEN
                  BEGIN
                    NUMB0 := PLUR; GEND0 := COMN;
                    IF ERC = 0
                      THEN CLASS := 0
                      ELSE INITSUBCL (TOK1, CLASS, VALID, 
                        NUMB0, GEND0, ANIM0);
                    
                    IF (TOK2 = '')          
                      THEN SUBCL := 237
                    ELSE IF (TOK2 = '')
                      THEN SUBCL := 10
                    ELSE INITSUBCL (TOK2, SUBCL, VALID, 
                        NUMB, GEND, ANIM0);
                    
                    IF (ERC > 0) AND (ANIM0 = YES) 
                      AND CAN_BE_ANIMATED (CLASS, ANCL)
                      THEN CLASS := ANCL;
                   END 
              ELSE IF (TOK1 = '') AND (TOK2 = '')
                THEN
                  BEGIN
                    SUBCL := 0;      CLASS := 37;
                    VALID := TRUE;   NUMB0 := PLUR;
                    GEND0 := COMN;   ANIM0 := NO;
                  END
              ELSE IF (TOK1 = '') AND (TOK2 = '')
                THEN
                  BEGIN
                    SUBCL := 0;      CLASS := 2;
                    VALID := TRUE;   NUMB0 := SING;
                    GEND0 := MASC;   ANIM0 := YES;
                  END
              ELSE IF (TOK1 = '') AND (TOK2 = '')
                THEN
                  BEGIN
                    SUBCL := 150;    CLASS := 0;
                    VALID := TRUE;   NUMB0 := SING;
                    GEND0 := MASC;   ANIM0 := YES;
                  END
             ELSE IF (TOK1 = '') AND (TOK2 = '')
                THEN
                  BEGIN
                    SUBCL := 151;    CLASS := 0;
                    VALID := TRUE;   NUMB0 := SING;
                    GEND0 := NEUT;   ANIM0 := NO;
                  END
             ELSE IF (TOK1 = '') AND (TOK2 = ' ') 
                  THEN 
                    BEGIN 
                      CLASS := 20;    SUBCL := 163;   
                      VALID := TRUE;  NUMB0 := PLUR;
                      GEND0 := COMN;  ANIM0 := YES;
                    END  
             ELSE IF (TOK1 = '') 
                AND ((TOK2 = '') OR (TOK2 = '') 
                  OR (TOK2 = '') OR (TOK2 = ''))
                THEN
                  BEGIN
                    CLASS := 169;   SUBCL := 30;
                    VALID := TRUE;  NUMB0 := PLUR;
                    GEND0 := COMN;  ANIM0 := NO;
                  END
              ELSE IF (TOK1 = '') 
                AND ((TOK2 = '') OR (TOK2 = '') 
                  OR (TOK2 = ''))
                THEN
                  BEGIN
                    CLASS := 169;   SUBCL := 90;
                    VALID := TRUE;  NUMB0 := PLUR;
                    GEND0 := COMN;  ANIM0 := NO;
                  END
              ELSE IF (TOK1 = '') AND (TOK2 = '')
                THEN
                  BEGIN
                    CLASS := 163;   SUBCL := 32;
                    VALID := TRUE;  NUMB0 := PLUR;
                    GEND0 := COMN;  ANIM0 := YES;
                  END
              ELSE IF (TOK1 = '') AND (TOK2 = '')
                THEN
                  BEGIN
                    CLASS := 162;   SUBCL := 20;
                    VALID := TRUE;  NUMB0 := SING;
                    GEND0 := NEUT;  ANIM0 := NO;
                  END
              ELSE IF (TOK1 = '') AND (TOK2 = '')
                THEN
                  BEGIN
                    CLASS := 169;   SUBCL := 39;
                    VALID := TRUE;  NUMB0 := PLUR;
                    GEND0 := COMN;  ANIM0 := NO;
                  END
              ELSE IF (TOK1 = '') AND (TOK2 = '') 
                THEN 
                  BEGIN 
                    CLASS := 169;   SUBCL := 12; 
                    VALID := TRUE;  NUMB0 := PLUR;
                    GEND0 := COMN;  ANIM0 := NO;
                 END
              ELSE IF (TOK1 = '') AND (TOK2 = '')
                THEN
                  BEGIN
                    CLASS := 163;   SUBCL := 146;
                    VALID := TRUE;  NUMB0 := PLUR;
                    GEND0 := COMN;  ANIM0 := YES;
                  END 
             { ELSE IF ((TOK1 = '') OR (TOK1 = '')) 
                AND (TOK2 = '')
                THEN
                  BEGIN
                    CLASS := 26;    SUBCL := 146;
                    VALID := TRUE;  NUMB0 := PLUR;
                    GEND0 := COMN;  ANIM0 := YES;
                  END }
              ELSE IF (TOK1 = '') AND (TOK2 = '')
                THEN
                  BEGIN
                    CLASS := 91;    SUBCL := 0;
                    VALID := TRUE;  NUMB0 := PLUR;
                    GEND0 := COMN;  ANIM0 := YES;
                  END
              ELSE SUBCL := 0;
            END;
        INC (TOTAL);
      END
end
      ELSE           { Collocation }
        IF LINE [3] = TILDE
          THEN   { Subject agreed against NUMB and GEND? }
            BEGIN
              VERB := COPY (LINE, 5, LENGTH (LINE) - 4);
              P := POS (TILDE, VERB);
              IF P > 0
                THEN VERB := COPY (VERB, P + 2, LENGTH (VERB)-P-1);
              TEST_VERB_FIN (VERB, NUMB, GEND);
              IF (NUMB > UNKN) AND (NUMB <> NUMB0) AND NOT THERE_IS_I
                THEN
                  IF VALID OR (CLASS = 17) OR (CLASS = 64) 
                    OR (CLASS = 75) OR (CLASS = 77) 
                    THEN WRITELN (FNAME, ' ERROR: Number collision at ',
                      HEADER, '=>', LINENUM)
                    ELSE
                      BEGIN
                        NG_CHANGE := TRUE;
                        NUMB0 := NUMB;
                      END;
              IF (GEND > NONE) AND (GEND <> GEND0) 
                AND NOT THERE_IS_I AND NOT THERE_IS_H
                THEN
                  IF VALID OR (CLASS = 17) OR (CLASS = 64) 
                    OR (CLASS = 75) OR (CLASS = 77) 
                    THEN WRITELN (FNAME, ' ERROR: Gender collision at ',
                      HEADER, '=>', LINENUM)
                    ELSE
                      BEGIN
                        NG_CHANGE := TRUE;
                        GEND0 := GEND;
                      END;
            END
          ELSE  { Supplement => to the structure under coding }
            BEGIN
              INC (PARTAMT);
              USACH := LINE [2];
              STYL := POS (USACH, 'sqpm*');
              IF (USACH <> BL) AND (STYL = 0)
                THEN
                  BEGIN
                    WRITELN (FNAME, ' ERROR: Wrong style label in line ',
                      LINENUM);
                    HALT;
                  END
                ELSE IF STYL > 0
                  THEN INC (USECOUNT [STYL]);

              IDIOM := POS (FIRST, '/\');

              CODE_LINE (PARTAMT, LINE);
              IF EOF (INP)
                THEN
                  BEGIN
                    OUT_HEADLINE;
                    PARTOUT;
                  END;
            END;
  UNTIL EOF (INP);
  CLOSE (INP);

  FLUSH (OUT);
  CLOSE (OUT);
END;

  FLUSH (OUT1);
  FLUSH (OUT2);

  FOR J := 8 TO MAXPREP29 DO
    WITH CASESETS [J] DO
      IF EXAMQUAN > 0
        THEN
          BEGIN
            WRITELN (OUTF, PREPCODE : 4, EXAMQUAN : 3, 
              BL, CASNO[CASNAME], BL2, CASTRING);
            FOR I := 1 TO EXAMQUAN DO
              WRITELN (OUTF, BL2, BL2, EXAMPLES [I,1], BL2, EXAMPLES [I,2]);
                
            WRITELN (OUTG, CASTRING, '<', CASNO[CASNAME]);
            FOR I := 1 TO EXAMQUAN DO
              WRITELN (OUTG, BL2, EXAMPLES2 [I]);  
          END;
  FLUSH (OUTF);
  FLUSH (OUTG);

{ WRITELN ('Groups total  ', TOTAL:4, ' = 100.00%');
  WRITELN ('   validated  ', AMT0 :4, ' =  ', AMT0/TOTAL*100 : 5 : 2, '%');
  WRITELN ('   accepted   ', AMT11:4, ' =  ', AMT11/TOTAL*100 : 5 : 2, '%');
  WRITELN ('   animated    ', AMT12:4, ' =  ', AMT12/TOTAL*100 : 5 : 2, '%');
  WRITELN ('   feminated   ', AMT13:4, ' =  ', AMT13/TOTAL*100 : 5 : 2, '%');
  WRITELN ('   masculated  ', AMT14:4, ' =  ', AMT14/TOTAL*100 : 5 : 2, '%');
  WRITELN ('   accentuated ', AMT15:4, ' =  ', AMT15/TOTAL*100 : 5 : 2, '%');
  WRITELN ('   corrected   ', AMT2 :4, ' =  ', AMT2/TOTAL*100 : 5 : 2, '%');
  WRITELN ('Marked: ', USECOUNT [1] : 4, ' specials');
  WRITELN ('        ', USECOUNT [2] : 4, ' colloquials');
  WRITELN ('        ', USECOUNT [3] : 4, ' indecents');
  WRITELN ('        ', USECOUNT [5] : 4, ' awkwards');  }
  
  WRITELN ('Files OPFUNC_0.LST, OPFUNC.COD, OPFUNCxx.COD, PREPO.LST,');
  WRITELN ('  SOBCOUNT.LST, MORFCASE.LST, VNEXAMPL.TXT, VNEXAMPL2.TXT output');

  PREPOTOTAL := 0;
  FOR J := 8 TO MAXPREP29 DO
    BEGIN
      WRITELN (OUT3, PREPO [J] : 7, BL, PREPOS [J].PRP);
      INC (PREPOTOTAL, PREPO [J]);
    END;
  WRITELN (OUT3, PREPOTOTAL, ' PREPS IN COLLOCATIONS');
  WRITELN (OUT5, PREPOTOTAL, ' PREPS IN COLLOCATIONS');
  
  WOPREPTOTAL := 0;
  FOR I := 0 TO 7 DO
    BEGIN
      CASE I OF
        0: WRITELN (OUT5, 'NOM: ', CAS_WO_PREP[0]:6);
        1: WRITELN (OUT5, 'GEN: ', CAS_WO_PREP[1]:6);
        2: WRITELN (OUT5, 'DAT: ', CAS_WO_PREP[2]:6);
        3: WRITELN (OUT5, 'ACC: ', CAS_WO_PREP[3]:6);
        4: WRITELN (OUT5, 'INS: ', CAS_WO_PREP[4]:6);
        6: WRITELN (OUT5, 'PAR: ', CAS_WO_PREP[6]:6);
      END;
      INC(WOPREPTOTAL, CAS_WO_PREP[I]);
    END;
  WRITELN (OUT5, WOPREPTOTAL, ' COLLOCATIONS W/O PREPS');

  ALLSOB := 0;
  INISOB := 0;
  FOR I := 0 TO 48 DO
    BEGIN
      WRITELN (OUT6, SOBOJ[I], BL : 17-LENGTH(SOBOJ[I]), SOB_COUNT[I] : 7);
      IF I > 0
        THEN ALLSOB := ALLSOB + SOB_COUNT[I];
      IF (I > 0) AND (I < 10)
        THEN INISOB := INISOB + SOB_COUNT[I];
    END;
  WRITELN (OUT6, INISOB / ALLSOB * 100 : 4 : 1, '% fertile reflexives');

  FLUSH (OUT3);
  FLUSH (OUT4);
  FLUSH (OUT5);
  FLUSH (OUT6);

  WRITELN (PREPOTOTAL, ' PREPOS IN PREPO.LST OUTPUT');
END.
